<!DOCTYPE HTML>
<html lang="zh_CN">
<head>
  <meta charset="utf-8">
  
  <title>介绍Objective-C运行时机制 | zlrs - blog</title>
  <meta name="author" content="zlrs">
  
  <meta name="description" content="本文写于2020年5月


本文是去年（2020年）阅读完《Object-oriented programming : an evolutionary approach》后整理的Objective-C runtime 的一些知识。介绍了OC和SmallTalk-80语言的历史、早期的OC实现、OC中">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="介绍Objective-C运行时机制"/>
  <meta property="og:site_name" content="zlrs - blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">zlrs - blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-介绍Objective-C运行时机制" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-09-14T15:53:39.000Z"><a href="/2021/09/14/%E4%BB%8B%E7%BB%8DObjective-C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA%E5%88%B6/">2021-09-14</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">介绍Objective-C运行时机制</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>本文写于2020年5月</p>
</blockquote>
<blockquote>
<p>本文是去年（2020年）阅读完《Object-oriented programming : an evolutionary approach》后整理的Objective-C runtime 的一些知识。<br>介绍了OC和SmallTalk-80语言的历史、早期的OC实现、OC中与运行时交互的3种方式、类的实现、消息绑定机制、super关键字与objc_msgSuper、KVO等内容。</p>
</blockquote>
<p>Runtime源码：<br><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/">https://opensource.apple.com/source/objc4/</a><br><a target="_blank" rel="noopener" href="https://github.com/0xxd0/objc4">https://github.com/0xxd0/objc4</a></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p><a href="2021/09/14/Objetive-C%E7%9A%84%E5%8E%86%E5%8F%B2/">Objective-C的历史</a><br><a href="2021/09/14/SmallTalk-80%E7%9A%84%E5%8E%86%E5%8F%B2/">SmallTalk-80的历史</a></p>
<h2 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h2><ul>
<li>尽可能延迟决策，动态绑定。</li>
<li>面向对象特性完全由 Runtime 提供</li>
<li>objc对象没有方法调用，而是消息发送(message expressions)。消息由Runtime动态解析到函数地址</li>
<li>对象都分配在堆上。Runtime内的内存管理模块做“引用计数”<ul>
<li>注意tagged pointer表面上是对象，实际上不是对象</li>
</ul>
</li>
<li>支持在运行时获得对象的信息（反射；自省）</li>
<li>支持在运行时添加新类、新方法</li>
<li>如果对象处理不了消息，还可以做消息转发<h2 id="早期（1980s）的OC实现"><a href="#早期（1980s）的OC实现" class="headerlink" title="早期（1980s）的OC实现"></a>早期（1980s）的OC实现</h2>早期的OC就是一个预处理器地位的存在。将面向对象语法翻译为C语言，然后再交给C编译器去编译。<br><img src="https://cdn.zlrs.site/mweb/2021/09/14/16316113089181.jpg"></li>
</ul>
<h2 id="runtime-版本"><a href="#runtime-版本" class="headerlink" title="runtime 版本"></a>runtime 版本</h2><p>Runtime 的实体是一个动态链接库(libobjc.dylib)。Objective-C语言很大程度上就是这个动态链接库。这个库主要有两个大版本：</p>
<ul>
<li>modern runtime: ObjC 2.0 for iPhone apps and 64bit apps on OSX.</li>
<li>legacy runtime: ObjC 1.0 for 32bit apps on OSX</li>
</ul>
<h2 id="和Runtime交互的形式"><a href="#和Runtime交互的形式" class="headerlink" title="和Runtime交互的形式"></a>和Runtime交互的形式</h2><ol>
<li>通过Objective-C Source Code<br>编译器将源代码中的类和方法转换成数据结构和动态特性的函数。数据结构从源码中提取类定义、分类定义、协议声明（class and category definitions and in protocol declarations）的信息。运行时系统的主要功能就是消息发送，由源码中的消息发送语句触发（invoked by source-code message expressions）.</li>
<li>通过NSObject的一些方法<br>NSObject的一些方法会问询runtime获得信息，一般为类方法。这些方法也被称为自省方法（self-introspect）</li>
</ol>
<ul>
<li>isKindOfClass:</li>
<li>isMemberOfClass:</li>
<li>respondsToSelector:</li>
<li>conformsToProtocol:</li>
<li>methodForSelector: （provides the address of a method’s implementation）</li>
</ul>
<ol start="3">
<li>直接调用运行时库函数 <code>#import &lt;objc/runtime.h&gt;</code><br>运行时库函数是C语言接口。其API可分为两种类型。</li>
</ol>
<ul>
<li>第一种类型允许你使用C函数去使用部分编译器的能力（allow you to use plain C to replicate what the compiler does when you write Objective-C code）. </li>
<li>第二种类型 form the basis for functionality exported through the methods of the NSObject class.</li>
</ul>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><p>源码：<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-235/runtime/objc-class.h.auto.html">https://opensource.apple.com/source/objc4/objc4-235/runtime/objc-class.h.auto.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span>                        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">isa</span>;</span>  <span class="comment">// 一般指向metaclass</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">super_class</span>;</span>  <span class="comment">// 指向父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">long</span> version;      <span class="comment">// 类的版本</span></span><br><span class="line">    <span class="keyword">long</span> info;</span><br><span class="line">    <span class="keyword">long</span> instance_size;  <span class="comment">// 实例变量大小之和</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span>   <span class="comment">// 保存实例变量的名字、类型、offset等信息，注意类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span>  <span class="comment">// 函数的查询表，注意类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span>  <span class="comment">// 消息查询结果的缓存表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="关于isa"><a href="#关于isa" class="headerlink" title="关于isa"></a>关于isa</h3><p>指向metaclass。</p>
<h3 id="关于super-class"><a href="#关于super-class" class="headerlink" title="关于super_class"></a>关于super_class</h3><p>指向父类。</p>
<h3 id="关于version"><a href="#关于version" class="headerlink" title="关于version"></a>关于version</h3><p>用来标识类的接口的变动，也就是为类的接口打版本。在序列化时特别有用，因为可以用它来表明类的实例变量的布局信息是否发生了变化。NSObject有类方法：setVersion:<br>关于instanceSize<br>alloc函数怎么知道要为实例申请多大的空间？就是看类对象的instanceSize。下面是new操作的一部分代码，节选自NSObject.mm中的static ALWAYS_INLINE id _class_createInstanceFromZone(Class cls, 后面参数省略…)函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line"></span><br><span class="line">id obj;</span><br><span class="line">if (zone) &#123;</span><br><span class="line">    obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    obj &#x3D; (id)calloc(1, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new方法的早期实现"><a href="#new方法的早期实现" class="headerlink" title="new方法的早期实现"></a>new方法的早期实现</h3><p>节选自《Object-oriented programming : an evolutionary approach》<br><img src="https://cdn.zlrs.site/mweb/2021/09/14/16316112931084.jpg"></p>
<h3 id="关于methodLists"><a href="#关于methodLists" class="headerlink" title="关于methodLists"></a>关于methodLists</h3><ol>
<li>注意：是methodLists而不是methodsList</li>
<li>methodLists是多个method List的线性表，其中最后一个元素是base method list，其它元素都是category method list</li>
<li>我们写类文件的时候，会写类方法和实例方法，实际上它们在编译后会注册到2个Class结构体中，其中实例方法进入类的Class结构体，类方法进入类的ISA，也就是metaclass，的Class结构体。具体请看方法的实现和消息机制。</li>
<li>可以在method list中查找SEL的IMP。这个列表可以是有序的，那么可以用二分查找；如果是无序的，可以用线性查找。</li>
</ol>
<h3 id="关于cache"><a href="#关于cache" class="headerlink" title="关于cache"></a>关于cache</h3><p>消息查找的缓存。大多数消息查找的耗时很少，因为它们会直接命中缓存。<br>class相关runtime API</p>
<ol>
<li>isKindOfClass:<br>判断对象是否是该类或该类派生类的实例。入参先去和ISA比较，再一路沿着super_class去比较。</li>
</ol>
<p>早期Object.m源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isKindOfClassNamed:(const char *)aClassName</span><br><span class="line">&#123;</span><br><span class="line">    register Class cls;</span><br><span class="line">    for (cls &#x3D; isa; cls; cls &#x3D; ((struct objc_class *)cls)-&gt;super_class) </span><br><span class="line">        if (strcmp(aClassName, ((struct objc_class *)cls)-&gt;name) &#x3D;&#x3D; 0)</span><br><span class="line">            return YES;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>近期NSObject.mm源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; self-&gt;ISA(); tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>isMemberOfClass:<br>判断对象是否是该类的直接实例。其实就是看receiver的isa和入参是不是一样。</li>
</ol>
<p>早期Object.m源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isMemberOfClassNamed:(const char *)aClassName &#123;</span><br><span class="line">    return strcmp(aClassName, ((struct objc_class *)isa)-&gt;name) &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>近期NSObject.mm源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return self-&gt;ISA() &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：以上的早期源码和近期的逻辑是一样的。可以看一下近期源码中class方法的实现，其实也是返回ISA。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NSObject.mm</span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; objc-class.mm</span><br><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* object_getClass.</span><br><span class="line">* Locking: None. If you add locking, tell gdb (rdar:&#x2F;&#x2F;7516456).</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">Class object_getClass(id obj) &#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法的实现"><a href="#方法的实现" class="headerlink" title="方法的实现"></a>方法的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">源码：https:&#x2F;&#x2F;opensource.apple.com&#x2F;source&#x2F;objc4&#x2F;objc4-235&#x2F;runtime&#x2F;objc-class.h.auto.html</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">        SEL method_name;</span><br><span class="line">        char *method_types;</span><br><span class="line">        IMP method_imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">        struct objc_method_list *obsolete;</span><br><span class="line"></span><br><span class="line">        int method_count;</span><br><span class="line">#ifdef __alpha__</span><br><span class="line">        int space;</span><br><span class="line">#endif</span><br><span class="line">        struct objc_method method_list[1];        &#x2F;* variable length structure *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译后，OC方法的数据结构是一个 <code>struct；</code>方法体会变为一个C函数，这个C函数前两个参数为对象指针/类对象指针和当前方法的SEL，参数列表为<code>(id self, SEL _cmd, ...)</code></p>
<h3 id="IMP的前2个参数"><a href="#IMP的前2个参数" class="headerlink" title="IMP的前2个参数"></a>IMP的前2个参数</h3><ol>
<li>The receiving object<br>对应我们在OC源代码的类方法或者实例方法中写的<code>self</code>。实例方法的<code>self</code>为该对象的指针。类方法的<code>self</code>为该类对象的指针。</li>
<li>The selector for the method<br>对应OC源码中的<code>_cmd</code>。<h3 id="方法的种类"><a href="#方法的种类" class="headerlink" title="方法的种类"></a>方法的种类</h3>C++中，方法被称为成员函数与静态成员函数。<br>Java中，方法被称为类方法与实例方法。<br>OC中，方法可以被分为：</li>
<li>实例方法（instance method）。方法前面是减号。这些方法会注册到本类的方法表中。</li>
<li>工厂方法（factory method）。“工厂”一词不是指设计模式，而是指类的工厂类（也就是类的metaclass）的方法。方法前面是加号。这些方法会注册到本类的工厂类，也就是metaclass的方法表中。<br>这里提到的方法表就是 objc_class.methodLists</li>
</ol>
<h2 id="对象内存模型与消息派发"><a href="#对象内存模型与消息派发" class="headerlink" title="对象内存模型与消息派发"></a>对象内存模型与消息派发</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>对象只存储状态（实例变量）；类只存储行为（方法）。</li>
<li>类和对象都有isa指针和superclass指针，作为其状态的一部分，即实例变量。</li>
<li>类和对象是一种模板-实例关系。且类和对象相对的概念；对类A的meta class而言，类A也是对象；对NSObject meta class而言，NSString meta class也是对象。NSObject比较特殊，它就是root的类，它不是任何人的对象（superclass指向nil）。</li>
<li>类方法和实例方法的派发，其实都是一样的。都是先找到receiver的isa，然后再一直向上找super class，直到到达NSObject为止。</li>
<li>因此所有的方法，包括类方法和实例方法，最终都是派发到NSObject。</li>
<li>对象的isa指针指向其类对象。类对象的isa指针指向类对象的metaclass对象；super class指针指向超类。metaclass对象的isa指针指向NSObject的metaclas对象。<h3 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h3><img src="https://cdn.zlrs.site/mweb/2021/09/14/16316113683323.jpg"></li>
</ol>
<h3 id="对象图（早期实现）"><a href="#对象图（早期实现）" class="headerlink" title="对象图（早期实现）"></a>对象图（早期实现）</h3><p><img src="https://cdn.zlrs.site/mweb/2021/09/14/16316113769760.jpg"></p>
<p>下面这张图节选自《Object-oriented programming : an evolutionary approach》，其中 Pen Software IC 指的就是Pen类。</p>
<h3 id="实例的消息派发"><a href="#实例的消息派发" class="headerlink" title="实例的消息派发"></a>实例的消息派发</h3><p><img src="https://cdn.zlrs.site/mweb/2021/09/14/16316113875747.jpg"></p>
<h3 id="类对象的消息派发"><a href="#类对象的消息派发" class="headerlink" title="类对象的消息派发"></a>类对象的消息派发</h3><p><img src="https://cdn.zlrs.site/mweb/2021/09/14/16316114039154.jpg"></p>
<h2 id="动态绑定与消息机制"><a href="#动态绑定与消息机制" class="headerlink" title="动态绑定与消息机制"></a>动态绑定与消息机制</h2><p>这是OC与C最大的不同。C的函数调用，在编译期完成函数绑定，函数地址会直接体现在每次函数调用中。而OC对象是通过消息机制在运行时完成绑定。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>Here is roughly how objc_msgSend function works:</p>
<ol>
<li>If the receiving object is nil, the message is redirected to nil receiver if any. The default behavior is to do nothing.</li>
<li>Check the class’s cache. If the implementation is already cached, call it.</li>
<li>Compare the selector to the selectors defined in the class. If a match is found, call the matched implementation. Otherwise, check its superclass until there is no superclass.</li>
<li>Call +resolveInstanceMethod:/+resolveClassMethod:. If it returns YES, it means the selector will resolve this time. So go to step 2 and start over. It is the place that you call class_addMethod to dynamically provide an implementation for the given selector.</li>
<li>Call -forwardingTargetForSelector:. If it returns non-nil, send the message to the returned object instead. Note that return self here will result in an infinite loop.</li>
<li>Call - methodSignatureForSelector:. If it returns non-nil, create an instance of NSInvocation, and pass it to -forwardInvocation:.</li>
<li>The implementation of the given selector cannot be found. It will call -doesNotRecognizeSelector: on the receiving object. The default implementation throws an exception.</li>
</ol>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>在OC中，消息是在运行时绑定的。编译器做的事情是：</p>
<ol>
<li>将<code>[receiver message]</code>消息发送式转换为<code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code>函数。</li>
<li>为每个类和对象建立数据结构，这个数据结构中包括 isa 指针和 class dispatch table（方法名到方法实现地址的查询表）。</li>
</ol>
<p><code>objc_msgSend</code>是一种messager。messager有几种，比如在向super发送消息时，会生成类似<code>objc_msgSuper</code>这样的messager。<br>这也是super关键字的原理。super并不是一个变量（self是），而是生成一种新的messager——msgSuper。<br>objc_msgSend做的事：</p>
<ol>
<li>根据receiver，查找SEL对应的IMP地址。这个查找分成3个层级</li>
<li>最高层，是那些需要被查找的类。这些类是继承树的一条路径，从receiver-&gt;isa开始，一直往继承树的根部，也就是NSObject的这样一条路径。objc_msgSend会按照顺序被查询路径上的每个类。</li>
<li>中间层，是对单个类的查询。每个类可能有多个函数列表（method list）。举个例子，对于NSObject来说，它首先有一个类文件中直接实现的method list，也会有很多category method list，这些是通过category添加上去的。</li>
<li>最底层，是对单个method list的查询。method list中存放了SEL到IMP的映射。它可能是有序的，也可能是无序的；查询的方式有二分查找和线性查找。</li>
<li>调用函数指针，传入2个隐藏的默认参数：receiver 和 selector，以及消息的参数。</li>
<li>返回函数调用的返回值。</li>
</ol>
<h4 id="动态方法解析-Dynamic-Method-Resolution"><a href="#动态方法解析-Dynamic-Method-Resolution" class="headerlink" title="动态方法解析 Dynamic Method Resolution"></a>动态方法解析 Dynamic Method Resolution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) resolveInstanceMethod:</span><br><span class="line">+ (BOOL) resolveClassMethod:</span><br></pre></td></tr></table></figure>
<p>动态方法解析是指为类添加方法（Method）到函数地址（IMP）的映射。<br>一个OC方法不过是一个至少接收2个参数——self和_cmd的C函数而已。使用class_addMethod函数，你就能动态地为一个类添加一个方法和方法实现。<br>resolveInstanceMethod:在OC的消息转发机制（forwarding mechanism）之前被调用，提供动态为一个类添加方法的机会。If respondsToSelector: or instancesRespondToSelector: is invoked, the dynamic method resolver is given the opportunity to provide an IMP for the given selector first.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    &#x2F;&#x2F; implementation ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL) resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL &#x3D;&#x3D; @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="转发-Forwarding"><a href="#转发-Forwarding" class="headerlink" title="转发 Forwarding"></a>转发 Forwarding</h4><p>如果对象认为自己不能响应消息，可以将消息转发给另一个对象。<br>若resolveInstanceMethod:返回NO，则对象可转发该消息。这其中又分为2小步。</p>
<h5 id="1-forwardingTargetForSelector"><a href="#1-forwardingTargetForSelector" class="headerlink" title="1.  - forwardingTargetForSelector:"></a>1.  - forwardingTargetForSelector:</h5><p>请接受者看看是否有其它对象（replacement receiver）能请求该消息。若有，运行时系统会把消息转给那个对象，消息转发结束。<code>- (id)forwardingTargetForSelector:(SEL)aSelector;</code>. 若可以处理，则返回处理消息的对象；若不能处理调用返回nil或者<code>[super forwardingTargetForSelector:]</code>。请注意，在这步中无法修改所转发的SEL。但是这一步的好处是代价比较低。</p>
<h5 id="2-methodSignatureForSelector-forwardInvocation"><a href="#2-methodSignatureForSelector-forwardInvocation" class="headerlink" title="2. - methodSignatureForSelector:  / - forwardInvocation:"></a>2. - methodSignatureForSelector:  / - forwardInvocation:</h5><p>若上一步函数返回nil，则启动完整的消息转发机制。先调用<code>- methodSignatureForSelector: </code>，若返回不为nil，则根据返回值将当前消息封装到NSInvocation对象中，调用<code>forwardInvocation: </code>，再给receiver最后一次机会处理该消息。这一步可以为消息追加参数或者修改SEL。<br>实现此方法时，若某消息不应由本类处理，则可以调用超类的同名方法。这样的话，继承树中的每个类都有机会处理此消息。优点是灵活，缺点是和相比<code>forwardingTargetForSelector:</code>代价较高。<br>doesNotRecognizeSelector<br>默认的实现是抛出异常</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果消息经过整套流转过程后，还不能被处理，就会产生异常。我们可以用try-catch捕获异常，也可以设置全局异常处理函数。</p>
<h3 id="受保护的代码"><a href="#受保护的代码" class="headerlink" title="受保护的代码"></a>受保护的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSObject* obj &#x3D; [[NSObject alloc] init];</span><br><span class="line"> </span><br><span class="line">@try &#123;</span><br><span class="line">  &#x2F;&#x2F; Attempt send a message that the receiver cannot understand</span><br><span class="line">  [obj performSelector:@selector(unknowMessage)];</span><br><span class="line">&#125;</span><br><span class="line">@catch (NSRangeException *exception) &#123;</span><br><span class="line">  NSLog( @&quot;Name: %@&quot;, exception.name);</span><br><span class="line">  NSLog( @&quot;Reason: %@&quot;, exception.reason);</span><br><span class="line">&#125;</span><br><span class="line">@finally &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行UncaughtExceptionHandler"><a href="#执行UncaughtExceptionHandler" class="headerlink" title="执行UncaughtExceptionHandler"></a>执行UncaughtExceptionHandler</h3><p>设置Handler：NSSetUncaughtExceptionHandler<br>Sets the top-level error-handling function where you can perform last-minute logging before the program terminates. The program then terminates, regardless of the actions taken by the uncaught exception handler.<br>Terminating app due to uncaught exception ‘NSInvalidArgumentException’<br>异常最终会导致crash。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="方法是消息的handler"><a href="#方法是消息的handler" class="headerlink" title="方法是消息的handler"></a>方法是消息的handler</h3><p>方法定义在哪里并不重要，重要的是第一个参数self是谁。<br>类更像是一个存放方法的容器，只不过这些方法一般是围绕实例的私有变量工作的，可以产生内聚。<br>A类的方法和B类的方法本质上没有什么不同，就是一个接受self和SEL作为前两个参数的C函数而已。假设A类和B类不在一棵继承树中，如果硬要拿B类的IMP来处理A类消息，应该也可以，只是一般不会这样做。<br>如果A类和B类有继承关系，那就很自然了。例如，不管给哪个类发new消息，一般都是解析到NSObject定义的new方法的IMP来处理。</p>
<h3 id="类函数和实例函数是相对的"><a href="#类函数和实例函数是相对的" class="headerlink" title="类函数和实例函数是相对的"></a>类函数和实例函数是相对的</h3><p>本类的类函数是本类的模板类的实例函数，加号和减号只是告诉runtime该方法应该注册到本类还是本类的模板类的函数表中。</p>
<h3 id="isa与superclass的语义"><a href="#isa与superclass的语义" class="headerlink" title="isa与superclass的语义"></a>isa与superclass的语义</h3><p>isa 描述实例-模板的关系；superclass描述子类-父类的继承关系。</p>
<h3 id="类消息和实例消息的派发方法是相同的"><a href="#类消息和实例消息的派发方法是相同的" class="headerlink" title="类消息和实例消息的派发方法是相同的"></a>类消息和实例消息的派发方法是相同的</h3><p>类消息和实例消息的派发，都是基于相同的算法。即先查询receiver的isa的函数表，再查询receiver的isa的superclass的函数表，再一直沿着被查询对象的superclass，直到查询到NSObject。若此时还没有查询到SEL，就进入后面的过程，即调用resolveInstanceMethod:等等。</p>
<h2 id="Further-Topics"><a href="#Further-Topics" class="headerlink" title="Further Topics"></a>Further Topics</h2><h3 id="SmallTalk-80的实现"><a href="#SmallTalk-80的实现" class="headerlink" title="SmallTalk-80的实现"></a>SmallTalk-80的实现</h3><p>《Smalltalk-80: The Language and its Implementation》, Addison-Wesley, 1983</p>
<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8733104/objective-c-property-instance-variable-in-category">https://stackoverflow.com/questions/8733104/objective-c-property-instance-variable-in-category</a><br>给Runtime提供的键必须是全局唯一的，比如一个静态变量的指针或者SEL。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>直接看代码。<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903796825391117">https://juejin.im/post/6844903796825391117</a></p>
<h4 id="Runtime-APIs"><a href="#Runtime-APIs" class="headerlink" title="Runtime APIs"></a>Runtime APIs</h4><ul>
<li>objc_setAssociatedObject</li>
<li>objc_getAssociatedObject</li>
<li>objc_removeAssociatedObjects</li>
</ul>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>观察者模式<br>原理：通过isa Swizzling添加中间类；中间类重写setter，给观察者发送属性变更通知、重写class方法返回原本的父类以隐藏自己。<br><img src="https://cdn.zlrs.site/mweb/2021/09/14/16316115725874.jpg"></p>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><h4 id="Getting-a-Method’s-Address"><a href="#Getting-a-Method’s-Address" class="headerlink" title="Getting a Method’s Address"></a>Getting a Method’s Address</h4><p>NSObject 的方法, methodForSelector: 传入一个selector，返回一个函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"> </span><br><span class="line">setter &#x3D; (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i &#x3D; 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<h4 id="Dynamic-loading"><a href="#Dynamic-loading" class="headerlink" title="Dynamic loading"></a>Dynamic loading</h4><p>An Objective-C program can load and link new classes and categories while it’s running. The new code is incorporated into the program and treated identically to classes and categories loaded at the start.<br>NSBundle类为Dynamic loading 提供了接口。<br>在运行时向类中添加方法和方法实现（通过<code>class_addMethod(Class, SEL, IMP, ...)</code>函数），本质上是在类的方法地址查询表中添加记录。<br>Method Swizzling 是在运行时向类中交换两个方法的实现。本质上是交换类的方法地址查询表中的两个键的值。<br>开发者常用此功能向原有实现中添加新功能，如UI自动数据上报。</p>
<h4 id="Related-APIs"><a href="#Related-APIs" class="headerlink" title="Related APIs"></a>Related APIs</h4><ol>
<li>Method class_getInstanceMethod(Class class, SEL selector)</li>
<li>void method_exchangeImplementations(Method m1, Method m2);<br><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/1418769-method_exchangeimplementations?language=objc">Apple Doc</a></li>
<li>IMP method_getImplementation(Method m);</li>
<li>IMP method_setImplementation(Method m, IMP imp);<br>Example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *str &#x3D; @&quot;lowercase-UPPERCASE&quot;;</span><br><span class="line"></span><br><span class="line">Method lowercaseMethod &#x3D; class_getInstanceMethod([NSString class], @selector(lowercaseString));</span><br><span class="line">Method uppercaseMethod &#x3D; class_getInstanceMethod([NSString class], @selector(uppercaseString));</span><br><span class="line">method_exchangeImplementations(lowercaseMethod, uppercaseMethod);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;call lowercaseString: %@&quot;, [str lowercaseString]);</span><br><span class="line">NSLog(@&quot;call uppercaseString: %@&quot;, [str uppercaseString]);</span><br></pre></td></tr></table></figure>
<h3 id="OC的对象模型"><a href="#OC的对象模型" class="headerlink" title="OC的对象模型"></a>OC的对象模型</h3></li>
</ol>
<ul>
<li>类 = 私有数据 + 共享操作</li>
<li>数据的“链接”<ul>
<li>对象布局</li>
</ul>
</li>
<li>操作的“链接”<ul>
<li>动态派发机制</li>
</ul>
</li>
</ul>
<h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="https://cdn.zlrs.site/mweb/2021/09/14/16316116657873.jpg"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>分析下面这段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation TestSuperMessager : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sayHello &#123;</span><br><span class="line">    [self someMethod];</span><br><span class="line">    [super someMethod2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>将其重写为C++: <code>clang -rewrite-objc main.m -o testMsg.cpp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @implementation TestSuperMessager : NSObject</span><br><span class="line"></span><br><span class="line">static void _I_TestSuperMessager_sayHello(TestSuperMessager * self, SEL _cmd) &#123;</span><br><span class="line">    ((id (*)(id, SEL, …))(void *)objc_msgSend)   &#x2F;&#x2F; objc_msgSend函数，做了类型cast</span><br><span class="line">    ((id)self, sel_registerName(“someMethod”));  &#x2F;&#x2F; 实参</span><br><span class="line"></span><br><span class="line">    ((id (*)(__rw_objc_super *, SEL, ...))(void *)objc_msgSendSuper) &#x2F;&#x2F;函数</span><br><span class="line">    ((__rw_objc_super)&#123;</span><br><span class="line">       (id)self, </span><br><span class="line">       (id)class_getSuperclass(objc_getClass(“TestSuperMessager&quot;))</span><br><span class="line">    &#125;, sel_registerName(“someMethod2”));  &#x2F;&#x2F; 实参</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下是Runtime的定义，和上面结合起来看</span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">   &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>编译器会为super关键字生成objc_msgSendSuper的messager</li>
<li>向super关键字发送消息，receiver还是self。只不过方法的查询起点由本类变成了父类。</li>
<li>由于语法的原因，我们可能会误解super是消息的receiver，其实并不是。</li>
<li>super的作用是指定方法搜索起点为父类，消息的receiver仍然是self。</li>
<li>[self class]和[super class]找到的IMP都是NSObject中的那个IMP。而找到IMP后，IMP的第一个实参还是self。所以调用的函数和传递的参数都相同，最后输出的类名当然也是相同的。</li>
</ul>
<h2 id="metaclass从何处来，是怎么被集成进应用的？"><a href="#metaclass从何处来，是怎么被集成进应用的？" class="headerlink" title="metaclass从何处来，是怎么被集成进应用的？"></a>metaclass从何处来，是怎么被集成进应用的？</h2><p>和编译、链接和加载有关。TODO</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>什么是运行时 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27179396">https://www.zhihu.com/question/27179396</a></li>
<li>OC消息派发和流转机制</li>
<li>概述 <a target="_blank" rel="noopener" href="https://medium.com/@guanshanliu/how-message-passing-works-in-objective-c-9e3d3dd70593">https://medium.com/@guanshanliu/how-message-passing-works-in-objective-c-9e3d3dd70593</a></li>
<li>消息分发机制 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/982116/objective-c-message-dispatch-mechanism">https://stackoverflow.com/questions/982116/objective-c-message-dispatch-mechanism</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5d47cfcb5188252d33698994#heading-9">https://juejin.im/post/5d47cfcb5188252d33698994#heading-9</a></li>
<li>从指令层面去分析objc_msgsend() <a target="_blank" rel="noopener" href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/">http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/</a></li>
<li>OC对象内存模型 </li>
<li>对象模型 <a target="_blank" rel="noopener" href="https://devalot.com/articles/2011/11/objc-object-model.html">https://devalot.com/articles/2011/11/objc-object-model.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34270138">https://zhuanlan.zhihu.com/p/34270138</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ObjectModeling/ObjectModeling.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ObjectModeling/ObjectModeling.html</a></li>
<li><a target="_blank" rel="noopener" href="https://devalot.com/articles/2011/11/objc-object-model.html">https://devalot.com/articles/2011/11/objc-object-model.html</a></li>
<li>SmallTalk相关</li>
<li>Reflective Facilities in Smalltalk-80 <a target="_blank" rel="noopener" href="http://www.laputan.org/ref89/ref89.html">http://www.laputan.org/ref89/ref89.html</a></li>
<li><a target="_blank" rel="noopener" href="https://techbeacon.com/app-dev-testing/how-learning-smalltalk-can-make-you-better-developer">https://techbeacon.com/app-dev-testing/how-learning-smalltalk-can-make-you-better-developer</a></li>
<li>《Object-oriented programming : an evolutionary approach》，出版于1986年，讲述了OOP的早期理论和各种实现方法，以及作者为什么要把OC设计成这样。作者是OC的发明者Cox, Brad <a target="_blank" rel="noopener" href="https://archive.org/details/objectorientedpr00coxb/page/n17/mode/1up">https://archive.org/details/objectorientedpr00coxb/page/n17/mode/1up</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/Objective-C-runtime/">Objective-C runtime</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://zlrs.github.io/2021/09/14/%E4%BB%8B%E7%BB%8DObjective-C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA%E5%88%B6/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="zlrs.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/C-C-11/">C++ C++11</a><small>1</small></li>
  
    <li><a href="/tags/Objective-C-runtime/">Objective-C runtime</a><small>1</small></li>
  
    <li><a href="/tags/Objetive-C-%E5%8E%86%E5%8F%B2/">Objetive-C 历史</a><small>1</small></li>
  
    <li><a href="/tags/ProgramDesign/">ProgramDesign</a><small>1</small></li>
  
    <li><a href="/tags/iOS-Objective-C-WWDC/">iOS Objective-C WWDC</a><small>1</small></li>
  
    <li><a href="/tags/macOS-iOS/">macOS iOS</a><small>3</small></li>
  
    <li><a href="/tags/%E7%BD%91%E7%BB%9C-iOS-macOS/">网络 iOS macOS</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 zlrs
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
