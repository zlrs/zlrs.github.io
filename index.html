<!DOCTYPE HTML>
<html lang="zh_CN">
<head>
  <meta charset="utf-8">
  
  <title>zlrs - blog</title>
  <meta name="author" content="zlrs">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="zlrs - blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">zlrs - blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-介绍Objective-C运行时机制" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-09-14T15:53:39.000Z"><a href="/2021/09/14/%E4%BB%8B%E7%BB%8DObjective-C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA%E5%88%B6/">2021-09-14</a></time>
      
      
  
    <h1 class="title"><a href="/2021/09/14/%E4%BB%8B%E7%BB%8DObjective-C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%BA%E5%88%B6/">介绍Objective-C运行时机制</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>本文写于2020年5月</p>
</blockquote>
<blockquote>
<p>本文是去年（2020年）阅读完《Object-oriented programming : an evolutionary approach》后整理的Objective-C runtime 的一些知识。<br>介绍了OC和SmallTalk-80语言的历史、早期的OC实现、OC中与运行时交互的3种方式、类的实现、消息绑定机制、super关键字与objc_msgSuper、KVO等内容。</p>
</blockquote>
<p>Runtime源码：<br><a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/">https://opensource.apple.com/source/objc4/</a><br><a target="_blank" rel="noopener" href="https://github.com/0xxd0/objc4">https://github.com/0xxd0/objc4</a></p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p><a href="2021/09/14/Objetive-C%E7%9A%84%E5%8E%86%E5%8F%B2/">Objective-C的历史</a><br><a href="2021/09/14/SmallTalk-80%E7%9A%84%E5%8E%86%E5%8F%B2/">SmallTalk-80的历史</a></p>
<h2 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h2><ul>
<li>尽可能延迟决策，动态绑定。</li>
<li>面向对象特性完全由 Runtime 提供</li>
<li>objc对象没有方法调用，而是消息发送(message expressions)。消息由Runtime动态解析到函数地址</li>
<li>对象都分配在堆上。Runtime内的内存管理模块做“引用计数”<ul>
<li>注意tagged pointer表面上是对象，实际上不是对象</li>
</ul>
</li>
<li>支持在运行时获得对象的信息（反射；自省）</li>
<li>支持在运行时添加新类、新方法</li>
<li>如果对象处理不了消息，还可以做消息转发<h2 id="早期（1980s）的OC实现"><a href="#早期（1980s）的OC实现" class="headerlink" title="早期（1980s）的OC实现"></a>早期（1980s）的OC实现</h2>早期的OC就是一个预处理器地位的存在。将面向对象语法翻译为C语言，然后再交给C编译器去编译。<br><img src="https://https//karl1b.blob.core.windows.net/mweb/2021/09/14/16316113089181.jpg"></li>
</ul>
<h2 id="runtime-版本"><a href="#runtime-版本" class="headerlink" title="runtime 版本"></a>runtime 版本</h2><p>Runtime 的实体是一个动态链接库(libobjc.dylib)。Objective-C语言很大程度上就是这个动态链接库。这个库主要有两个大版本：</p>
<ul>
<li>modern runtime: ObjC 2.0 for iPhone apps and 64bit apps on OSX.</li>
<li>legacy runtime: ObjC 1.0 for 32bit apps on OSX</li>
</ul>
<h2 id="和Runtime交互的形式"><a href="#和Runtime交互的形式" class="headerlink" title="和Runtime交互的形式"></a>和Runtime交互的形式</h2><ol>
<li>通过Objective-C Source Code<br>编译器将源代码中的类和方法转换成数据结构和动态特性的函数。数据结构从源码中提取类定义、分类定义、协议声明（class and category definitions and in protocol declarations）的信息。运行时系统的主要功能就是消息发送，由源码中的消息发送语句触发（invoked by source-code message expressions）.</li>
<li>通过NSObject的一些方法<br>NSObject的一些方法会问询runtime获得信息，一般为类方法。这些方法也被称为自省方法（self-introspect）</li>
</ol>
<ul>
<li>isKindOfClass:</li>
<li>isMemberOfClass:</li>
<li>respondsToSelector:</li>
<li>conformsToProtocol:</li>
<li>methodForSelector: （provides the address of a method’s implementation）</li>
</ul>
<ol start="3">
<li>直接调用运行时库函数 <code>#import &lt;objc/runtime.h&gt;</code><br>运行时库函数是C语言接口。其API可分为两种类型。</li>
</ol>
<ul>
<li>第一种类型允许你使用C函数去使用部分编译器的能力（allow you to use plain C to replicate what the compiler does when you write Objective-C code）. </li>
<li>第二种类型 form the basis for functionality exported through the methods of the NSObject class.</li>
</ul>
<h2 id="类的实现"><a href="#类的实现" class="headerlink" title="类的实现"></a>类的实现</h2><p>源码：<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-235/runtime/objc-class.h.auto.html">https://opensource.apple.com/source/objc4/objc4-235/runtime/objc-class.h.auto.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span>                        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">isa</span>;</span>  <span class="comment">// 一般指向metaclass</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">super_class</span>;</span>  <span class="comment">// 指向父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">long</span> version;      <span class="comment">// 类的版本</span></span><br><span class="line">    <span class="keyword">long</span> info;</span><br><span class="line">    <span class="keyword">long</span> instance_size;  <span class="comment">// 实例变量大小之和</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>;</span>   <span class="comment">// 保存实例变量的名字、类型、offset等信息，注意类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>;</span>  <span class="comment">// 函数的查询表，注意类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>;</span>  <span class="comment">// 消息查询结果的缓存表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="关于isa"><a href="#关于isa" class="headerlink" title="关于isa"></a>关于isa</h3><p>指向metaclass。</p>
<h3 id="关于super-class"><a href="#关于super-class" class="headerlink" title="关于super_class"></a>关于super_class</h3><p>指向父类。</p>
<h3 id="关于version"><a href="#关于version" class="headerlink" title="关于version"></a>关于version</h3><p>用来标识类的接口的变动，也就是为类的接口打版本。在序列化时特别有用，因为可以用它来表明类的实例变量的布局信息是否发生了变化。NSObject有类方法：setVersion:<br>关于instanceSize<br>alloc函数怎么知道要为实例申请多大的空间？就是看类对象的instanceSize。下面是new操作的一部分代码，节选自NSObject.mm中的static ALWAYS_INLINE id _class_createInstanceFromZone(Class cls, 后面参数省略…)函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size &#x3D; cls-&gt;instanceSize(extraBytes);</span><br><span class="line">if (outAllocatedSize) *outAllocatedSize &#x3D; size;</span><br><span class="line"></span><br><span class="line">id obj;</span><br><span class="line">if (zone) &#123;</span><br><span class="line">    obj &#x3D; (id)malloc_zone_calloc((malloc_zone_t *)zone, 1, size);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    obj &#x3D; (id)calloc(1, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new方法的早期实现"><a href="#new方法的早期实现" class="headerlink" title="new方法的早期实现"></a>new方法的早期实现</h3><p>节选自《Object-oriented programming : an evolutionary approach》<br><img src="https://https//karl1b.blob.core.windows.net/mweb/2021/09/14/16316112931084.jpg"></p>
<h3 id="关于methodLists"><a href="#关于methodLists" class="headerlink" title="关于methodLists"></a>关于methodLists</h3><ol>
<li>注意：是methodLists而不是methodsList</li>
<li>methodLists是多个method List的线性表，其中最后一个元素是base method list，其它元素都是category method list</li>
<li>我们写类文件的时候，会写类方法和实例方法，实际上它们在编译后会注册到2个Class结构体中，其中实例方法进入类的Class结构体，类方法进入类的ISA，也就是metaclass，的Class结构体。具体请看方法的实现和消息机制。</li>
<li>可以在method list中查找SEL的IMP。这个列表可以是有序的，那么可以用二分查找；如果是无序的，可以用线性查找。</li>
</ol>
<h3 id="关于cache"><a href="#关于cache" class="headerlink" title="关于cache"></a>关于cache</h3><p>消息查找的缓存。大多数消息查找的耗时很少，因为它们会直接命中缓存。<br>class相关runtime API</p>
<ol>
<li>isKindOfClass:<br>判断对象是否是该类或该类派生类的实例。入参先去和ISA比较，再一路沿着super_class去比较。</li>
</ol>
<p>早期Object.m源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isKindOfClassNamed:(const char *)aClassName</span><br><span class="line">&#123;</span><br><span class="line">    register Class cls;</span><br><span class="line">    for (cls &#x3D; isa; cls; cls &#x3D; ((struct objc_class *)cls)-&gt;super_class) </span><br><span class="line">        if (strcmp(aClassName, ((struct objc_class *)cls)-&gt;name) &#x3D;&#x3D; 0)</span><br><span class="line">            return YES;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>近期NSObject.mm源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; self-&gt;ISA(); tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>isMemberOfClass:<br>判断对象是否是该类的直接实例。其实就是看receiver的isa和入参是不是一样。</li>
</ol>
<p>早期Object.m源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isMemberOfClassNamed:(const char *)aClassName &#123;</span><br><span class="line">    return strcmp(aClassName, ((struct objc_class *)isa)-&gt;name) &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>近期NSObject.mm源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return self-&gt;ISA() &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：以上的早期源码和近期的逻辑是一样的。可以看一下近期源码中class方法的实现，其实也是返回ISA。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NSObject.mm</span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; objc-class.mm</span><br><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* object_getClass.</span><br><span class="line">* Locking: None. If you add locking, tell gdb (rdar:&#x2F;&#x2F;7516456).</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">Class object_getClass(id obj) &#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法的实现"><a href="#方法的实现" class="headerlink" title="方法的实现"></a>方法的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">源码：https:&#x2F;&#x2F;opensource.apple.com&#x2F;source&#x2F;objc4&#x2F;objc4-235&#x2F;runtime&#x2F;objc-class.h.auto.html</span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">        SEL method_name;</span><br><span class="line">        char *method_types;</span><br><span class="line">        IMP method_imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">        struct objc_method_list *obsolete;</span><br><span class="line"></span><br><span class="line">        int method_count;</span><br><span class="line">#ifdef __alpha__</span><br><span class="line">        int space;</span><br><span class="line">#endif</span><br><span class="line">        struct objc_method method_list[1];        &#x2F;* variable length structure *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译后，OC方法的数据结构是一个 <code>struct；</code>方法体会变为一个C函数，这个C函数前两个参数为对象指针/类对象指针和当前方法的SEL，参数列表为<code>(id self, SEL _cmd, ...)</code></p>
<h3 id="IMP的前2个参数"><a href="#IMP的前2个参数" class="headerlink" title="IMP的前2个参数"></a>IMP的前2个参数</h3><ol>
<li>The receiving object<br>对应我们在OC源代码的类方法或者实例方法中写的<code>self</code>。实例方法的<code>self</code>为该对象的指针。类方法的<code>self</code>为该类对象的指针。</li>
<li>The selector for the method<br>对应OC源码中的<code>_cmd</code>。<h3 id="方法的种类"><a href="#方法的种类" class="headerlink" title="方法的种类"></a>方法的种类</h3>C++中，方法被称为成员函数与静态成员函数。<br>Java中，方法被称为类方法与实例方法。<br>OC中，方法可以被分为：</li>
<li>实例方法（instance method）。方法前面是减号。这些方法会注册到本类的方法表中。</li>
<li>工厂方法（factory method）。“工厂”一词不是指设计模式，而是指类的工厂类（也就是类的metaclass）的方法。方法前面是加号。这些方法会注册到本类的工厂类，也就是metaclass的方法表中。<br>这里提到的方法表就是 objc_class.methodLists</li>
</ol>
<h2 id="对象内存模型与消息派发"><a href="#对象内存模型与消息派发" class="headerlink" title="对象内存模型与消息派发"></a>对象内存模型与消息派发</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>对象只存储状态（实例变量）；类只存储行为（方法）。</li>
<li>类和对象都有isa指针和superclass指针，作为其状态的一部分，即实例变量。</li>
<li>类和对象是一种模板-实例关系。且类和对象相对的概念；对类A的meta class而言，类A也是对象；对NSObject meta class而言，NSString meta class也是对象。NSObject比较特殊，它就是root的类，它不是任何人的对象（superclass指向nil）。</li>
<li>类方法和实例方法的派发，其实都是一样的。都是先找到receiver的isa，然后再一直向上找super class，直到到达NSObject为止。</li>
<li>因此所有的方法，包括类方法和实例方法，最终都是派发到NSObject。</li>
<li>对象的isa指针指向其类对象。类对象的isa指针指向类对象的metaclass对象；super class指针指向超类。metaclass对象的isa指针指向NSObject的metaclas对象。<h3 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h3><img src="https://https//karl1b.blob.core.windows.net/mweb/2021/09/14/16316113683323.jpg"></li>
</ol>
<h3 id="对象图（早期实现）"><a href="#对象图（早期实现）" class="headerlink" title="对象图（早期实现）"></a>对象图（早期实现）</h3><p><img src="https://https//karl1b.blob.core.windows.net/mweb/2021/09/14/16316113769760.jpg"></p>
<p>下面这张图节选自《Object-oriented programming : an evolutionary approach》，其中 Pen Software IC 指的就是Pen类。</p>
<h3 id="实例的消息派发"><a href="#实例的消息派发" class="headerlink" title="实例的消息派发"></a>实例的消息派发</h3><p><img src="https://https//karl1b.blob.core.windows.net/mweb/2021/09/14/16316113875747.jpg"></p>
<h3 id="类对象的消息派发"><a href="#类对象的消息派发" class="headerlink" title="类对象的消息派发"></a>类对象的消息派发</h3><p><img src="https://https//karl1b.blob.core.windows.net/mweb/2021/09/14/16316114039154.jpg"></p>
<h2 id="动态绑定与消息机制"><a href="#动态绑定与消息机制" class="headerlink" title="动态绑定与消息机制"></a>动态绑定与消息机制</h2><p>这是OC与C最大的不同。C的函数调用，在编译期完成函数绑定，函数地址会直接体现在每次函数调用中。而OC对象是通过消息机制在运行时完成绑定。</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>Here is roughly how objc_msgSend function works:</p>
<ol>
<li>If the receiving object is nil, the message is redirected to nil receiver if any. The default behavior is to do nothing.</li>
<li>Check the class’s cache. If the implementation is already cached, call it.</li>
<li>Compare the selector to the selectors defined in the class. If a match is found, call the matched implementation. Otherwise, check its superclass until there is no superclass.</li>
<li>Call +resolveInstanceMethod:/+resolveClassMethod:. If it returns YES, it means the selector will resolve this time. So go to step 2 and start over. It is the place that you call class_addMethod to dynamically provide an implementation for the given selector.</li>
<li>Call -forwardingTargetForSelector:. If it returns non-nil, send the message to the returned object instead. Note that return self here will result in an infinite loop.</li>
<li>Call - methodSignatureForSelector:. If it returns non-nil, create an instance of NSInvocation, and pass it to -forwardInvocation:.</li>
<li>The implementation of the given selector cannot be found. It will call -doesNotRecognizeSelector: on the receiving object. The default implementation throws an exception.</li>
</ol>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>在OC中，消息是在运行时绑定的。编译器做的事情是：</p>
<ol>
<li>将<code>[receiver message]</code>消息发送式转换为<code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code>函数。</li>
<li>为每个类和对象建立数据结构，这个数据结构中包括 isa 指针和 class dispatch table（方法名到方法实现地址的查询表）。</li>
</ol>
<p><code>objc_msgSend</code>是一种messager。messager有几种，比如在向super发送消息时，会生成类似<code>objc_msgSuper</code>这样的messager。<br>这也是super关键字的原理。super并不是一个变量（self是），而是生成一种新的messager——msgSuper。<br>objc_msgSend做的事：</p>
<ol>
<li>根据receiver，查找SEL对应的IMP地址。这个查找分成3个层级</li>
<li>最高层，是那些需要被查找的类。这些类是继承树的一条路径，从receiver-&gt;isa开始，一直往继承树的根部，也就是NSObject的这样一条路径。objc_msgSend会按照顺序被查询路径上的每个类。</li>
<li>中间层，是对单个类的查询。每个类可能有多个函数列表（method list）。举个例子，对于NSObject来说，它首先有一个类文件中直接实现的method list，也会有很多category method list，这些是通过category添加上去的。</li>
<li>最底层，是对单个method list的查询。method list中存放了SEL到IMP的映射。它可能是有序的，也可能是无序的；查询的方式有二分查找和线性查找。</li>
<li>调用函数指针，传入2个隐藏的默认参数：receiver 和 selector，以及消息的参数。</li>
<li>返回函数调用的返回值。</li>
</ol>
<h4 id="动态方法解析-Dynamic-Method-Resolution"><a href="#动态方法解析-Dynamic-Method-Resolution" class="headerlink" title="动态方法解析 Dynamic Method Resolution"></a>动态方法解析 Dynamic Method Resolution</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) resolveInstanceMethod:</span><br><span class="line">+ (BOOL) resolveClassMethod:</span><br></pre></td></tr></table></figure>
<p>动态方法解析是指为类添加方法（Method）到函数地址（IMP）的映射。<br>一个OC方法不过是一个至少接收2个参数——self和_cmd的C函数而已。使用class_addMethod函数，你就能动态地为一个类添加一个方法和方法实现。<br>resolveInstanceMethod:在OC的消息转发机制（forwarding mechanism）之前被调用，提供动态为一个类添加方法的机会。If respondsToSelector: or instancesRespondToSelector: is invoked, the dynamic method resolver is given the opportunity to provide an IMP for the given selector first.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    &#x2F;&#x2F; implementation ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL) resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL &#x3D;&#x3D; @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="转发-Forwarding"><a href="#转发-Forwarding" class="headerlink" title="转发 Forwarding"></a>转发 Forwarding</h4><p>如果对象认为自己不能响应消息，可以将消息转发给另一个对象。<br>若resolveInstanceMethod:返回NO，则对象可转发该消息。这其中又分为2小步。</p>
<h5 id="1-forwardingTargetForSelector"><a href="#1-forwardingTargetForSelector" class="headerlink" title="1.  - forwardingTargetForSelector:"></a>1.  - forwardingTargetForSelector:</h5><p>请接受者看看是否有其它对象（replacement receiver）能请求该消息。若有，运行时系统会把消息转给那个对象，消息转发结束。<code>- (id)forwardingTargetForSelector:(SEL)aSelector;</code>. 若可以处理，则返回处理消息的对象；若不能处理调用返回nil或者<code>[super forwardingTargetForSelector:]</code>。请注意，在这步中无法修改所转发的SEL。但是这一步的好处是代价比较低。</p>
<h5 id="2-methodSignatureForSelector-forwardInvocation"><a href="#2-methodSignatureForSelector-forwardInvocation" class="headerlink" title="2. - methodSignatureForSelector:  / - forwardInvocation:"></a>2. - methodSignatureForSelector:  / - forwardInvocation:</h5><p>若上一步函数返回nil，则启动完整的消息转发机制。先调用<code>- methodSignatureForSelector: </code>，若返回不为nil，则根据返回值将当前消息封装到NSInvocation对象中，调用<code>forwardInvocation: </code>，再给receiver最后一次机会处理该消息。这一步可以为消息追加参数或者修改SEL。<br>实现此方法时，若某消息不应由本类处理，则可以调用超类的同名方法。这样的话，继承树中的每个类都有机会处理此消息。优点是灵活，缺点是和相比<code>forwardingTargetForSelector:</code>代价较高。<br>doesNotRecognizeSelector<br>默认的实现是抛出异常</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果消息经过整套流转过程后，还不能被处理，就会产生异常。我们可以用try-catch捕获异常，也可以设置全局异常处理函数。</p>
<h3 id="受保护的代码"><a href="#受保护的代码" class="headerlink" title="受保护的代码"></a>受保护的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSObject* obj &#x3D; [[NSObject alloc] init];</span><br><span class="line"> </span><br><span class="line">@try &#123;</span><br><span class="line">  &#x2F;&#x2F; Attempt send a message that the receiver cannot understand</span><br><span class="line">  [obj performSelector:@selector(unknowMessage)];</span><br><span class="line">&#125;</span><br><span class="line">@catch (NSRangeException *exception) &#123;</span><br><span class="line">  NSLog( @&quot;Name: %@&quot;, exception.name);</span><br><span class="line">  NSLog( @&quot;Reason: %@&quot;, exception.reason);</span><br><span class="line">&#125;</span><br><span class="line">@finally &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行UncaughtExceptionHandler"><a href="#执行UncaughtExceptionHandler" class="headerlink" title="执行UncaughtExceptionHandler"></a>执行UncaughtExceptionHandler</h3><p>设置Handler：NSSetUncaughtExceptionHandler<br>Sets the top-level error-handling function where you can perform last-minute logging before the program terminates. The program then terminates, regardless of the actions taken by the uncaught exception handler.<br>Terminating app due to uncaught exception ‘NSInvalidArgumentException’<br>异常最终会导致crash。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="方法是消息的handler"><a href="#方法是消息的handler" class="headerlink" title="方法是消息的handler"></a>方法是消息的handler</h3><p>方法定义在哪里并不重要，重要的是第一个参数self是谁。<br>类更像是一个存放方法的容器，只不过这些方法一般是围绕实例的私有变量工作的，可以产生内聚。<br>A类的方法和B类的方法本质上没有什么不同，就是一个接受self和SEL作为前两个参数的C函数而已。假设A类和B类不在一棵继承树中，如果硬要拿B类的IMP来处理A类消息，应该也可以，只是一般不会这样做。<br>如果A类和B类有继承关系，那就很自然了。例如，不管给哪个类发new消息，一般都是解析到NSObject定义的new方法的IMP来处理。</p>
<h3 id="类函数和实例函数是相对的"><a href="#类函数和实例函数是相对的" class="headerlink" title="类函数和实例函数是相对的"></a>类函数和实例函数是相对的</h3><p>本类的类函数是本类的模板类的实例函数，加号和减号只是告诉runtime该方法应该注册到本类还是本类的模板类的函数表中。</p>
<h3 id="isa与superclass的语义"><a href="#isa与superclass的语义" class="headerlink" title="isa与superclass的语义"></a>isa与superclass的语义</h3><p>isa 描述实例-模板的关系；superclass描述子类-父类的继承关系。</p>
<h3 id="类消息和实例消息的派发方法是相同的"><a href="#类消息和实例消息的派发方法是相同的" class="headerlink" title="类消息和实例消息的派发方法是相同的"></a>类消息和实例消息的派发方法是相同的</h3><p>类消息和实例消息的派发，都是基于相同的算法。即先查询receiver的isa的函数表，再查询receiver的isa的superclass的函数表，再一直沿着被查询对象的superclass，直到查询到NSObject。若此时还没有查询到SEL，就进入后面的过程，即调用resolveInstanceMethod:等等。</p>
<h2 id="Further-Topics"><a href="#Further-Topics" class="headerlink" title="Further Topics"></a>Further Topics</h2><h3 id="SmallTalk-80的实现"><a href="#SmallTalk-80的实现" class="headerlink" title="SmallTalk-80的实现"></a>SmallTalk-80的实现</h3><p>《Smalltalk-80: The Language and its Implementation》, Addison-Wesley, 1983</p>
<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8733104/objective-c-property-instance-variable-in-category">https://stackoverflow.com/questions/8733104/objective-c-property-instance-variable-in-category</a><br>给Runtime提供的键必须是全局唯一的，比如一个静态变量的指针或者SEL。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>直接看代码。<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903796825391117">https://juejin.im/post/6844903796825391117</a></p>
<h4 id="Runtime-APIs"><a href="#Runtime-APIs" class="headerlink" title="Runtime APIs"></a>Runtime APIs</h4><ul>
<li>objc_setAssociatedObject</li>
<li>objc_getAssociatedObject</li>
<li>objc_removeAssociatedObjects</li>
</ul>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>观察者模式<br>原理：通过isa Swizzling添加中间类；中间类重写setter，给观察者发送属性变更通知、重写class方法返回原本的父类以隐藏自己。<br><img src="https://https//karl1b.blob.core.windows.net/mweb/2021/09/14/16316115725874.jpg"></p>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><h4 id="Getting-a-Method’s-Address"><a href="#Getting-a-Method’s-Address" class="headerlink" title="Getting a Method’s Address"></a>Getting a Method’s Address</h4><p>NSObject 的方法, methodForSelector: 传入一个selector，返回一个函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line"> </span><br><span class="line">setter &#x3D; (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i &#x3D; 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<h4 id="Dynamic-loading"><a href="#Dynamic-loading" class="headerlink" title="Dynamic loading"></a>Dynamic loading</h4><p>An Objective-C program can load and link new classes and categories while it’s running. The new code is incorporated into the program and treated identically to classes and categories loaded at the start.<br>NSBundle类为Dynamic loading 提供了接口。<br>在运行时向类中添加方法和方法实现（通过<code>class_addMethod(Class, SEL, IMP, ...)</code>函数），本质上是在类的方法地址查询表中添加记录。<br>Method Swizzling 是在运行时向类中交换两个方法的实现。本质上是交换类的方法地址查询表中的两个键的值。<br>开发者常用此功能向原有实现中添加新功能，如UI自动数据上报。</p>
<h4 id="Related-APIs"><a href="#Related-APIs" class="headerlink" title="Related APIs"></a>Related APIs</h4><ol>
<li>Method class_getInstanceMethod(Class class, SEL selector)</li>
<li>void method_exchangeImplementations(Method m1, Method m2);<br><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/1418769-method_exchangeimplementations?language=objc">Apple Doc</a></li>
<li>IMP method_getImplementation(Method m);</li>
<li>IMP method_setImplementation(Method m, IMP imp);<br>Example:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSString *str &#x3D; @&quot;lowercase-UPPERCASE&quot;;</span><br><span class="line"></span><br><span class="line">Method lowercaseMethod &#x3D; class_getInstanceMethod([NSString class], @selector(lowercaseString));</span><br><span class="line">Method uppercaseMethod &#x3D; class_getInstanceMethod([NSString class], @selector(uppercaseString));</span><br><span class="line">method_exchangeImplementations(lowercaseMethod, uppercaseMethod);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;call lowercaseString: %@&quot;, [str lowercaseString]);</span><br><span class="line">NSLog(@&quot;call uppercaseString: %@&quot;, [str uppercaseString]);</span><br></pre></td></tr></table></figure>
<h3 id="OC的对象模型"><a href="#OC的对象模型" class="headerlink" title="OC的对象模型"></a>OC的对象模型</h3></li>
</ol>
<ul>
<li>类 = 私有数据 + 共享操作</li>
<li>数据的“链接”<ul>
<li>对象布局</li>
</ul>
</li>
<li>操作的“链接”<ul>
<li>动态派发机制</li>
</ul>
</li>
</ul>
<h3 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="https://https//karl1b.blob.core.windows.net/mweb/2021/09/14/16316116657873.jpg"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>分析下面这段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation TestSuperMessager : NSObject</span><br><span class="line"></span><br><span class="line">- (void)sayHello &#123;</span><br><span class="line">    [self someMethod];</span><br><span class="line">    [super someMethod2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>将其重写为C++: <code>clang -rewrite-objc main.m -o testMsg.cpp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @implementation TestSuperMessager : NSObject</span><br><span class="line"></span><br><span class="line">static void _I_TestSuperMessager_sayHello(TestSuperMessager * self, SEL _cmd) &#123;</span><br><span class="line">    ((id (*)(id, SEL, …))(void *)objc_msgSend)   &#x2F;&#x2F; objc_msgSend函数，做了类型cast</span><br><span class="line">    ((id)self, sel_registerName(“someMethod”));  &#x2F;&#x2F; 实参</span><br><span class="line"></span><br><span class="line">    ((id (*)(__rw_objc_super *, SEL, ...))(void *)objc_msgSendSuper) &#x2F;&#x2F;函数</span><br><span class="line">    ((__rw_objc_super)&#123;</span><br><span class="line">       (id)self, </span><br><span class="line">       (id)class_getSuperclass(objc_getClass(“TestSuperMessager&quot;))</span><br><span class="line">    &#125;, sel_registerName(“someMethod2”));  &#x2F;&#x2F; 实参</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; @end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下是Runtime的定义，和上面结合起来看</span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">   &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>编译器会为super关键字生成objc_msgSendSuper的messager</li>
<li>向super关键字发送消息，receiver还是self。只不过方法的查询起点由本类变成了父类。</li>
<li>由于语法的原因，我们可能会误解super是消息的receiver，其实并不是。</li>
<li>super的作用是指定方法搜索起点为父类，消息的receiver仍然是self。</li>
<li>[self class]和[super class]找到的IMP都是NSObject中的那个IMP。而找到IMP后，IMP的第一个实参还是self。所以调用的函数和传递的参数都相同，最后输出的类名当然也是相同的。</li>
</ul>
<h2 id="metaclass从何处来，是怎么被集成进应用的？"><a href="#metaclass从何处来，是怎么被集成进应用的？" class="headerlink" title="metaclass从何处来，是怎么被集成进应用的？"></a>metaclass从何处来，是怎么被集成进应用的？</h2><p>和编译、链接和加载有关。TODO</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>什么是运行时 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/27179396">https://www.zhihu.com/question/27179396</a></li>
<li>OC消息派发和流转机制</li>
<li>概述 <a target="_blank" rel="noopener" href="https://medium.com/@guanshanliu/how-message-passing-works-in-objective-c-9e3d3dd70593">https://medium.com/@guanshanliu/how-message-passing-works-in-objective-c-9e3d3dd70593</a></li>
<li>消息分发机制 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/982116/objective-c-message-dispatch-mechanism">https://stackoverflow.com/questions/982116/objective-c-message-dispatch-mechanism</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5d47cfcb5188252d33698994#heading-9">https://juejin.im/post/5d47cfcb5188252d33698994#heading-9</a></li>
<li>从指令层面去分析objc_msgsend() <a target="_blank" rel="noopener" href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/">http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/</a></li>
<li>OC对象内存模型 </li>
<li>对象模型 <a target="_blank" rel="noopener" href="https://devalot.com/articles/2011/11/objc-object-model.html">https://devalot.com/articles/2011/11/objc-object-model.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34270138">https://zhuanlan.zhihu.com/p/34270138</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ObjectModeling/ObjectModeling.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ObjectModeling/ObjectModeling.html</a></li>
<li><a target="_blank" rel="noopener" href="https://devalot.com/articles/2011/11/objc-object-model.html">https://devalot.com/articles/2011/11/objc-object-model.html</a></li>
<li>SmallTalk相关</li>
<li>Reflective Facilities in Smalltalk-80 <a target="_blank" rel="noopener" href="http://www.laputan.org/ref89/ref89.html">http://www.laputan.org/ref89/ref89.html</a></li>
<li><a target="_blank" rel="noopener" href="https://techbeacon.com/app-dev-testing/how-learning-smalltalk-can-make-you-better-developer">https://techbeacon.com/app-dev-testing/how-learning-smalltalk-can-make-you-better-developer</a></li>
<li>《Object-oriented programming : an evolutionary approach》，出版于1986年，讲述了OOP的早期理论和各种实现方法，以及作者为什么要把OC设计成这样。作者是OC的发明者Cox, Brad <a target="_blank" rel="noopener" href="https://archive.org/details/objectorientedpr00coxb/page/n17/mode/1up">https://archive.org/details/objectorientedpr00coxb/page/n17/mode/1up</a></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-Objetive-C的历史" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-09-14T14:04:46.000Z"><a href="/2021/09/14/Objetive-C%E7%9A%84%E5%8E%86%E5%8F%B2/">2021-09-14</a></time>
      
      
  
    <h1 class="title"><a href="/2021/09/14/Objetive-C%E7%9A%84%E5%8E%86%E5%8F%B2/">Objetive-C的历史</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>本文写于2020年7月</p>
</blockquote>
<h2 id="大事年表"><a href="#大事年表" class="headerlink" title="大事年表"></a>大事年表</h2><table>
<thead>
<tr>
<th>时间</th>
<th>事件</th>
</tr>
</thead>
<tbody><tr>
<td>1981</td>
<td>Brad Cox和Tom Love受到SmallTalk的启发，编写了一个用于支持SmallTalk语法的预处理器。Cox开始思考软件系统的重用问题。</td>
</tr>
<tr>
<td>1983</td>
<td>Cox和Love合伙创办PPI，销售Objective-C和相关库（他们称之为Software IC）</td>
</tr>
<tr>
<td>1986</td>
<td>Cox出版《Object-Oriented Programming, An Evolutionary Approach》，介绍OC。</td>
</tr>
<tr>
<td>1988</td>
<td>NeXT买下OC授权，并推动GCC支持OC编译，还开发了AppKit和FoundationKit，作为UI编程库和基础库。</td>
</tr>
<tr>
<td>1992</td>
<td>GNU支持Objective-C（GNUStep）i.e. 支持Linux平台。</td>
</tr>
<tr>
<td>1996</td>
<td>苹果收购NeXT，包括OC、InterfaceBuilder、ProjectBuilder。NeXTStep开发环境被重命名为Cocoa。</td>
</tr>
<tr>
<td>2006</td>
<td>Objective-C 2.0（之前是叫objc4）。随iOS4一起发布。新增ARC，属性，64位支持，Class extensions，Associated Objects，tagged pointer等特性。</td>
</tr>
<tr>
<td>2011</td>
<td>Xcode 4.0发布，采用LLVM作为默认编译器。</td>
</tr>
<tr>
<td>2016</td>
<td>微软发布WinObjC，为Windows提供Objective-C开发环境</td>
</tr>
</tbody></table>
<h2 id="早期时代"><a href="#早期时代" class="headerlink" title="早期时代"></a>早期时代</h2><p>Objective-C 主要由 Stepstone 公司的布莱德·考克斯（Brad Cox）和 汤姆·洛夫（Tom Love） 在 1980 年代发明。</p>
<p>1981年 Brad Cox 和 Tom Love 还在 ITT 公司技术中心任职时，接触到了 SmallTalk语言。Cox 当时对软件设计和开发问题非常感兴趣，他很快地意识到 SmallTalk语言 在系统工程构建中具有无法估量的价值，但同时他和 Tom Love 也明白，目前 ITT 公司的电子通信工程相关技术中，C 语言被放在很重要的位置。</p>
<p>于是 Cox 撰写了一个 C 语言的预处理器，打算使 C 语言具备些许 Smalltalk 的本领。Cox 很快地实现了一个可用的 C 语言扩展，此即为 Objective-C语言的前身。到了 1983 年，Cox 与 Love 合伙成立了 Productivity Products International（PPI）公司，将 Objective-C 及其相关库商品化贩售，并在之后将公司改名为StepStone。1986年，Cox 出版了一本关于 Objective-C 的重要著作《Object-Oriented Programming, An Evolutionary Approach》，书内详述了 Objective-C 的种种设计理念。</p>
<h2 id="NextStep时代"><a href="#NextStep时代" class="headerlink" title="NextStep时代"></a>NextStep时代</h2><p>1988年，斯蒂夫·乔布斯（Steve Jobs）离开苹果公司后成立了 NeXT Computer 公司，NeXT 公司买下 Objective-C 语言的授权，并扩展了著名的开源编译器GCC 使之支持 Objective-C 的编译，基于 Objective-C 开发了 AppKit 与 Foundation Kit 等库，作为 NeXTSTEP 的的用户界面与开发环境的基础。虽然 NeXT 工作站后来在市场上失败了，但 NeXT 上的软件工具却在业界中被广泛赞扬。这促使 NeXT 公司放弃硬件业务，转型为销售NeXTStep（以及OpenStep）平台为主的软件公司。</p>
<p>1992年，自由软件基金会的 GNU 开发环境增加了对 Objective-C 的支持。1994年，NeXT Computer公司和Sun Microsystem联合发布了一个针对 NEXTSTEP 系统的标准典范，名为 OPENSTEP。OPENSTEP 在自由软件基金会的实现名称为 GNUstep。</p>
<h2 id="Apple时代"><a href="#Apple时代" class="headerlink" title="Apple时代"></a>Apple时代</h2><p>1996年12月20日，苹果公司宣布收购 NeXT Software 公司，NEXTSTEP/OPENSTEP环境成为苹果操作系统下一个主要发行版本OS X的基础。这个开发环境的版本被苹果公司称为Cocoa。</p>
<p>2005年，苹果电脑雇用了克里斯·拉特纳及LLVM开发团队[4]，clang及LLVM成为苹果公司在GCC之外的新编译器选择，在 Xcode 4.0之后均采用 LLVM 作为默认的编译器。最新的 Modern Objective-C 特性也都率先在 Clang 上实现。</p>
<p>2016年，微软发布WinObjC，作为Windows-iOS Bridge的基础，为Windows提供了Objective-C开发环境。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-SmallTalk-80的历史" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-09-14T14:04:46.000Z"><a href="/2021/09/14/SmallTalk-80%E7%9A%84%E5%8E%86%E5%8F%B2/">2021-09-14</a></time>
      
      
  
    <h1 class="title"><a href="/2021/09/14/SmallTalk-80%E7%9A%84%E5%8E%86%E5%8F%B2/">SmallTalk-80的历史</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>本文写于2020年7月</p>
</blockquote>
<h2 id="为解决软件危机而诞生的语言"><a href="#为解决软件危机而诞生的语言" class="headerlink" title="为解决软件危机而诞生的语言"></a>为解决软件危机而诞生的语言</h2><p>1960s发生了软件危机：</p>
<ul>
<li>软件规模越来越大、复杂度越来越高，但是缺乏有效软件工程工具和技术方案。导致软件的开发成功率极低。</li>
<li>市场对软件的需求指数增长，但是程序员的产能增长远远落后于需求的增长。而且缺乏有效的需求管理工具和开发、测试理论，这些因素导致软件开发不断延期。</li>
<li>语言偏底层，可读性、代码复用率、可拓展性、可测试性较低，不利于复杂项目的协作。</li>
<li>缺少库、包管理机制，代码极难复用。<br>SmallTalk作为一种面向对象语言，承担了解决以上问题的责任。</li>
</ul>
<h2 id="SmallTalk-80简介"><a href="#SmallTalk-80简介" class="headerlink" title="SmallTalk-80简介"></a>SmallTalk-80简介</h2><p>Smalltalk是一种面向对象的、动态类型的编程语言。学院派应对软件危机的OOP。<br>Smalltalk对众多现代语言起到了深远的影响，主要有：C++，C#，Objective-C，Actor，Java和Ruby等。<br>Smalltalk影响了90年代的许多软件开发思想，例如设计模式、敏捷编程和代码重构等。<br>在Smalltalk中所有的东西都是对象，或者应该被当作对象处理。例如下面的表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 + 3</span><br></pre></td></tr></table></figure>
<p>应当被理解为：向对象2发送消息+，参数为对象3。</p>
<p>SmallTalk的面向对象是如此的彻底，甚至于连条件判断、循环等功能都是由类提供的。</p>
<p>许多现代概念都可以在古老的SmallTalk中找到，比如metaclass、tagged pointer、消息机制等。</p>
<h2 id="ST-语法示例"><a href="#ST-语法示例" class="headerlink" title="ST 语法示例"></a>ST 语法示例</h2><p><img src="https://cdn.zlrs.site/mweb/2021/09/14/16315997831842.jpg"></p>
<h2 id="SmallTalk-80-IDE"><a href="#SmallTalk-80-IDE" class="headerlink" title="SmallTalk-80 IDE"></a>SmallTalk-80 IDE</h2><p>ST 的 IDE 对现代 IDE 也影响深远<br>ST-80 IDE已经具备了代码编辑、文件浏览器、符号浏览器等基础功能：<br><img src="https://cdn.zlrs.site/mweb/2021/09/14/16315998877426.jpg"></p>
<h2 id="ST的不足"><a href="#ST的不足" class="headerlink" title="ST的不足"></a>ST的不足</h2><p>它最初是以研究为目的开发的，在执行效率、商业推广等存在不足。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-C-11中的移动语义" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-09-09T21:19:29.000Z"><a href="/2021/09/09/C-11%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/">2021-09-09</a></time>
      
      
  
    <h1 class="title"><a href="/2021/09/09/C-11%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/">C++11中的移动语义</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="引入移动语义（move-semantics）的背景"><a href="#引入移动语义（move-semantics）的背景" class="headerlink" title="引入移动语义（move semantics）的背景"></a>引入移动语义（move semantics）的背景</h2><p>C++03（及之前）禁止修改临时对象。然而，在一些情况下，临时对象是可以被修改的。（这里可以的意思是，理论上可以做到这一点，但是语言未实现此操作）。并且如果支持修改临时对象，在某些场合，就不必通过copy ctor构造新对象（这会造成对资源的深拷贝），而是“偷走”临时对象的资源，这可以提高效率。</p>
<p>为了实现这一点，C++需要提供一种新的构造函数和赋值操作符函数。而为了提供这类函数，C++必须增加一种新的型别。</p>
<p>因此C++11引入了右值引用这一型别，用来指代（refer to）一个可以被修改的临时对象。同时增加了std::move，用于将一个值的型别强转为右值引用。同时增加了移动构造函数和移动赋值操作符函数。</p>
<p>在这篇文章里，我们首先观察C++11提供的各种型别，并重点理解右值引用。然后我们会探索<code>std::move</code>的实现。最后文章提供了一个简单的Demo，说明C++11引入移动语义的动机。</p>
<h2 id="C-11型别"><a href="#C-11型别" class="headerlink" title="C++11型别"></a>C++11型别</h2><ul>
<li>左值（lvalue）<ul>
<li>有人称之为“有位置的值”（能取地址）或“有名字的值”。</li>
<li><code>int x = 5;</code>中的x。能对x取地址，所以x是左值。</li>
</ul>
</li>
<li>右值（rvalue）<ul>
<li>纯右值（Pure Rvalue，即C++98中的右值）<ul>
<li>临时变量、不与名字关联的字面量值。</li>
<li><code>int x = 5;</code> 中的5. 5（在语言层面上）不具有内存地址，是右值。</li>
<li><code>true</code>/<code>false</code></li>
<li><code>x+1</code></li>
</ul>
</li>
<li>临终值（xvalue）</li>
</ul>
</li>
<li>临终值（xvalue, eXpiring Value）（C++11引入）<ul>
<li>临终值的意思是，该对象即将停止使用，并且可以被移走内容。</li>
<li>临终值不是左值，因为不能取地址。</li>
<li>临终值不是纯右值，因为可以有名字（identity）。（可以参考 <a target="_blank" rel="noopener" href="https://riptutorial.com/cplusplus/example/2604/xvalue">C++ Tutorial =&gt; xvalue</a>）</li>
<li>C++11标准把临终值与左值合称为广义左值，即指向某个物理存在的对象；把临终值与纯右值（对应C++03时的右值概念）合称为右值（C++11重新定义的概念），其内容可以移走（该右值生命期到此为止，此后将不再使用）。</li>
</ul>
</li>
<li>左值引用<ul>
<li>对左值的引用</li>
</ul>
</li>
<li>右值引用（C++11引入）<ul>
<li>对右值的引用</li>
<li>用于支持C++11的移动语义和完美转发</li>
</ul>
</li>
<li>cv (const and volatile) type qualifiers</li>
<li>万能引用（universal reference）<ul>
<li>可以被绑定到左值或右值</li>
<li>If a variable or parameter is declared to have type T&amp;&amp; for some deduced type T, that variable or parameter is a universal reference.</li>
<li>在实践当中，几乎所有的universal references都是函数模板的参数。因为auto声明的变量的类型推导规则本质上和模板是一样的，所以使用auto的时候你也可能得到一个universal references。使用typedef和decltype的时候也可能会出现universal references。</li>
</ul>
</li>
</ul>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>一个做类型转换的模板函数。将一个值作为std::move的参数的含义是，告诉编译器这个参数是一个可以被“移动”（偷走资源）的对象，暗示这个对象是一个临时对象或之后不会被使用的对象，因此被偷走资源也没有关系。<br>伪代码: </p>
<blockquote>
<p>右值引用（去除引用（参数））</p>
</blockquote>
<p>示例实现（与STL的实现在原理上一致）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp;</span><br><span class="line">move(T&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    using ReturnType &#x3D; typename remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    return static_cast&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>下面这个程序说明了C++11引入移动语义的动机。<br>下面的程序定义了String类和Entity类。Entity拥有一个String类的成员。在main函数中，我们通过一个临时的String对象去构造Entity对象。如果不使用移动语义，就只能通过String类的复制构造函数来构造Entity类的String成员，这会发生一次深拷贝。引入移动语义后，Entity类的String成员直接“偷走”了临时对象的资源，避免了深拷贝。<br>直接运行这个程序，将输出</p>
<blockquote>
<p>Copyed!<br> Destroyed 5 bytes data at 0x102105710!<br> Destroyed 5 bytes data at 0x102105720!</p>
</blockquote>
<p>取消程序中的注释，将使用C++11移动语义。此时再运行，将输出</p>
<blockquote>
<p> Moved!<br> Destroyed 0 bytes data at 0x0!<br> Destroyed 5 bytes data at 0x1079aa8c0!</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// default ctor</span></span><br><span class="line">  String() = <span class="keyword">default</span>;</span><br><span class="line">   </span><br><span class="line">  String(<span class="keyword">const</span> <span class="keyword">char</span> *c_str) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(c_str);</span><br><span class="line">    m_size = size;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_data, c_str, size);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// copy ctor</span></span><br><span class="line">  String(<span class="keyword">const</span> String &amp;other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copyed!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">size_t</span> size = other.m_size;</span><br><span class="line">    m_size = size;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_data, other.m_data, size);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 取消此处注释以启用C++11移动语义</span></span><br><span class="line"><span class="comment">  // move ctor</span></span><br><span class="line"><span class="comment">  // @param other String对象的右值引用</span></span><br><span class="line"><span class="comment">  String(String &amp;&amp;other) noexcept &#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;Moved!\n&quot;);</span></span><br><span class="line"><span class="comment">    // steal resources!</span></span><br><span class="line"><span class="comment">    m_data = other.m_data;</span></span><br><span class="line"><span class="comment">    m_size = other.m_size;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    other.m_data = nullptr;</span></span><br><span class="line"><span class="comment">    other.m_size = 0;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  ~String() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Destroyed %zu bytes data at %p!\n&quot;</span>, m_size, m_data);</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_size; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span> *m_data;</span><br><span class="line">  <span class="keyword">size_t</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Entity(<span class="keyword">const</span> String &amp;name): m_name(name) &#123;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 取消此处注释以启用C++11移动语义</span></span><br><span class="line"><span class="comment">  Entity(String &amp;&amp;name): m_name(std::move(name)) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_name.Print();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  String m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This program demonstrates the motivation of move semantics</span></span><br><span class="line">  <span class="comment">// 解除掉String类和Entity类的两个以右值引用为形参的构造函数的注释，再试试</span></span><br><span class="line">  <span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Effective Modern C++</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3106110/what-is-move-semantics">What is move semantics?</a></li>
<li><a target="_blank" rel="noopener" href="https://riptutorial.com/cplusplus/example/2604/xvalue">C++ Tutorial =&gt; xvalue</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-探索Xcode命令行工具系统（三）：切换Toolchain（介绍xcode-select和xcrun）" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-31T11:12:34.000Z"><a href="/2021/08/31/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%87%E6%8D%A2Toolchain%EF%BC%88%E4%BB%8B%E7%BB%8Dxcode-select%E5%92%8Cxcrun%EF%BC%89/">2021-08-31</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/31/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%87%E6%8D%A2Toolchain%EF%BC%88%E4%BB%8B%E7%BB%8Dxcode-select%E5%92%8Cxcrun%EF%BC%89/">探索Xcode命令行工具系统（三）：切换Toolchain（介绍xcode-select和xcrun）</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Mac上的每个Xcode APP都内置了一套工具链。工具链也可以单独下载，并部署在单独的文件夹中（如公司AppHealth团队维护的toolchain）。因此，一台Mac上可能存在多套工具链。</p>
<blockquote>
<p>注：下面会混用toolchain和Command Line Tools两种说法。Command Line Tools包含了toolchain。</p>
</blockquote>
<p>为了便于Toolchain的切换，苹果做了如下事情：</p>
<ol>
<li>提供“桩命令”. 具体什么是”桩命令”，可以参考<strong>探索Xcode命令行工具系统（二）：git命令的调用过程</strong>。 举个例子，<code>/usr/bin/git</code>和<code>/usr/bin/clang</code>都是桩命令，对他们的调用实际上是调用到当前toolchain中的对应命令。</li>
<li>提供<code>xcode-select</code>命令和<code>DEVELOPER_DIR</code>环境变量，用于指定当前toolchain</li>
<li>提供<code>xcrun</code>，用于运行当前toolchain中的命令或者打印该命令的路径。</li>
</ol>
<h2 id="xcode-select介绍"><a href="#xcode-select介绍" class="headerlink" title="xcode-select介绍"></a>xcode-select介绍</h2><p>这里简单介绍下参数和用法，具体用法可以看命令的manpage。</p>
<ol>
<li><code>-p</code>参数：打印当前toolchain路径。</li>
<li><code>-s</code>参数：指定系统级toolchain路径。需要<code>sudo</code>权限。将影响本机上所有的用户。</li>
<li><code>DEVELOPER_DIR</code>环境变量：用于指定当前环境的toolchain路径。可以覆盖系统级别的toolchain路径。</li>
</ol>
<p>toolchain的路径一般在Xcode APP中，如<code>/Application/Xcode.app/Contents/Developer</code>（也可以写成<code>/Application/Xcode.app</code>，<code>xcode-select</code>会自动添加后面的部分）. 或者单独存在。</p>
<p>开发者也可以在Xcode IDE中切换系统级的toolchain（Command Line Tools）. 切换时需要指纹验证来获取sudo权限。其底层应该也是通过调用<code>xcode-select</code>实现。<br><img src="https://cdn.zlrs.site/mweb/2021/08/31/16285887284120.jpg" alt="-w942"></p>
<p><strong>配合桩命令和<code>xcode-select</code>，就可以方便地切换toolchain。</strong><br>举个例子：假设我们在编译脚本中存在这样一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild xxx.c -xxxx  # 参数省略</span><br></pre></td></tr></table></figure>
<p>一般来说，<code>xcodebuild</code>会被解析到桩命令<code>/usr/bin/xcodebuild</code>，桩命令再调到当前toolchain的<code>xcodebuild</code>。</p>
<p>问题：如果PATH头部存在其它Toolchain目录，则<code>xcodebuild</code>不会解析到桩命令。<br>如对于以下Path：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=”/Applications/Xcode12.3.app/Contents/Developer/usr/bin:$&#123;PATH&#125;”</span><br></pre></td></tr></table></figure>
<p><code>xcodebuild</code>被会解析到<code>/Applications/Xcode12.3.app/Contents/Developer/usr/bin/xcodebuild</code>，而不是桩命令，从而无法随toolchain的切换而改变路径。</p>
<h2 id="xcrun-介绍"><a href="#xcrun-介绍" class="headerlink" title="xcrun 介绍"></a>xcrun 介绍</h2><p>这里简单介绍下参数和用法，具体用法可以看命令的manpage。</p>
<ol>
<li>执行当前toolchain的某个命令，如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun git status</span><br></pre></td></tr></table></figure></li>
<li>查找命令的路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhuyuanqing@C02D70XMMD6R ~&#x2F;B&#x2F;tools&gt; xcrun --find clang</span><br><span class="line">&#x2F;Applications&#x2F;Xcode12.3.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang</span><br><span class="line">zhuyuanqing@C02D70XMMD6R ~&#x2F;B&#x2F;tools&gt; xcrun --find git</span><br><span class="line">&#x2F;Applications&#x2F;Xcode12.3.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;git</span><br></pre></td></tr></table></figure>
即使PATH头部存在其它Toolchain目录，<code>xcrun --find xcodebuild</code>依然能解析到当前Toolchain的路径。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ PATH&#x3D;&quot;&#x2F;Applications&#x2F;Xcode12.3.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin:$&#123;PATH&#125;&quot;</span><br><span class="line"></span><br><span class="line">$ which xcodebuild                                                     </span><br><span class="line">&#x2F;Applications&#x2F;Xcode12.3.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;xcodebuild</span><br><span class="line"></span><br><span class="line">$ xcrun --find xcodebuild</span><br><span class="line">&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;xcodebuild</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>我们可以通过<code>xcode-select</code>方便地切换系统Toolchain；用<code>DEVELOPER_DIR</code>环境变量切换当前Shell session的Toolchain。</li>
<li>在编写编译脚本时，有两种编写方法<ol>
<li>使用桩命令（如<code>/usr/bin/xcodebuild</code>）运行当前Toolchain中的命令。</li>
<li>使用<code>xcrun</code>运行当前Toolchain中的命令，或<code>xcrun --find</code>在当前Toolchain中查找命令。</li>
</ol>
</li>
</ol>
<p><code>xcrun</code>的工作细节，可以参考<a target="_blank" rel="noopener" href="https://lapcatsoftware.com/articles/xcrun.html">这篇文章</a>.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://support.macincloud.com/support/solutions/articles/8000042681-how-to-utilize-a-different-xcode-version-for-build-process-on-mac">how-to-utilize-a-different-xcode-version-for-build-process-on-mac</a></p>
<p><a target="_blank" rel="noopener" href="https://dive.medium.com/multiple-xcode-versions-or-why-xcrun-is-your-friend-ed3935b054b">multiple-xcode-versions-or-why-xcrun-is-your-friend</a></p>
<p><a target="_blank" rel="noopener" href="https://lapcatsoftware.com/articles/xcrun.html">xcrun details</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-误用单例模式造成的问题（以开发一个SDK为例）" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-14T18:59:01.000Z"><a href="/2021/08/14/%E8%AF%AF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BB%A5%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AASDK%E4%B8%BA%E4%BE%8B%EF%BC%89/">2021-08-14</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/14/%E8%AF%AF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BB%A5%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AASDK%E4%B8%BA%E4%BE%8B%EF%BC%89/">误用单例模式造成的问题（以开发一个SDK为例）</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>这里以开发一个AppLog SDK的例子来说明误用单例模式会造成哪些问题。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>开发的第一步，是确定SDK的功能。我们假设AppLog SDK有以下功能：</p>
<ul>
<li>埋点上报</li>
<li>本次启动未来得及上报的埋点，可以在下次启动时上报</li>
<li>能自动为以下事件做埋点：应用启动、进入前台、进入后台和应用退出</li>
</ul>
<h2 id="细分功能点和讨论软件开发面"><a href="#细分功能点和讨论软件开发面" class="headerlink" title="细分功能点和讨论软件开发面"></a>细分功能点和讨论软件开发面</h2><ul>
<li>埋点上报<ul>
<li>需要一个SDK主类，作为用户界面</li>
</ul>
</li>
<li>本次启动未来得及上报的埋点，可以在下次启动时上报<ul>
<li>埋点数据要持久化到磁盘。需要数据库访问层（DAO）。</li>
<li>需要埋点上报层，并支持不同上报策略（定时上报，手动触发上报等）</li>
</ul>
</li>
<li>能自动为以下事件做埋点：应用启动、进入前台、进入后台和应用退出<ul>
<li>需要一个监听上述生命周期事件的对象</li>
</ul>
</li>
</ul>
<h2 id="讨论实现：完全使用单例模式来实现"><a href="#讨论实现：完全使用单例模式来实现" class="headerlink" title="讨论实现：完全使用单例模式来实现"></a>讨论实现：完全使用单例模式来实现</h2><p>经过以上两步我们分析完了AppLog SDK的功能点，并分出了用户界面层、数据库访问层、上报服务层和应用生命周期埋点层。我简单花了一个层级图表示层间的关系。（这张图不能完全反映软件的真实关系，比如若用户有手动触发上报的需求，则用户页面也需要依赖上报服务的上报接口，从而用户界面画成“L形”会更合适。但是这并不妨碍我们接下来的分析。）</p>
<p> <img src="https://cdn.zlrs.site/mweb/2021/08/14/16289281989139.jpg" alt="我们划分出的软件层级"></p>
<p> 因为每个层最少使用一个对象就可以完成，所以我们很容易想到用每个层都用一个单例。可以定义以下单例：</p>
<ul>
<li>[AppLogSDK sharedInstance]</li>
<li>[AppLogSDKImpl sharedInstance]</li>
<li>[AppLogDAO sharedInstance]</li>
<li>[AppLogReportService sharedInstance]</li>
<li>[AppLogAppLifeCycleTrack sharedInstance]</li>
</ul>
<p>单例之间的通信就是层间通信。5个单例的相互通信实现了埋点数据的流转。这可以让我们的SDK正常工作。但是存在以下代价：</p>
<ol>
<li>单例具有“惯性”。因为后续的开发者会贴近之前代码的实现风格，所以仓库中的单例会随着时间越来越多。可能某个需求用单例实现是不够佳的，但是因为codebase中已经全是单例了，所以后续的开发者往往也会用单例来实现。</li>
<li>难以看清类之间的依赖关系。这是因为单例具有全局名字空间，所以依赖一个单例的对象无需在其接口（成员变量）中声明，而只需要随用随取即可。为了确定依赖，我们不得不去看代码中具体的调用点。（特别是在Objective-C中，一个类的代码可能分布在多个文件，更是令人头疼）这也为静态分析、依赖分析工具的开发增加了难度。当然，作为软件的第一任开发者和依赖关系的最初设计者，你在一开始肯定了解这其中的关系，只是对于新人和N月后再看代码的你来说有难度。</li>
<li>难以编写单元测试。单元测试简单的说就是先确定一个类所有重要的test case，通过mock掉它所有的依赖+并运行被测代码(CUT, Code Under Test)来确定这个类的代码有没有问题。但是由于单例是随用随取的，我们很难去mock CUT对单例的依赖。(在这里例子里，由于AppLogImpl直接依赖了AppLogDAO单例，test case就无从mock数据库依赖)这样我们就无法确定出错时是CUT的错误还是依赖的错误；甚至单测通过时也无法确定是否是“错错得对”。</li>
<li>容易承担过多职责，造成类级别的职责混乱。由于众多单例之间交叉调用的数据流是非常难解读的，而需求紧急时没有足够的时间去了解整个codebase的数据流。这样新人做需求时就容易往已有的单例上添加其他职责，造成职责混乱。</li>
<li>内存占用较高。单例具有静态生命周期，只有在进程退出时才会被析构。当不再需要某个单例时，这个单例也会一直存在，直到进程退出。</li>
<li>较难找到单例的创建时间。要确定单例的创建时间，得先找到所有<code>sharedInstance</code>的调用点，然后在这些调用点中找到时间上最前的那个。当你要为单例注入外部依赖时，弄清这一点是很重要的，否则外部依赖的注入可能晚于单例第一个方法调用。</li>
<li>当未来需求变化时有潜在的巨大改造成本。想象一下，当单例难以满足新增需求时，如需求要求有多个埋点渠道、上报渠道、数据库为了合规也得按渠道隔离；那么单例的设计就会存在很大的改造成本。</li>
</ol>
<h2 id="讨论实现：使用组合设计模式来实现"><a href="#讨论实现：使用组合设计模式来实现" class="headerlink" title="讨论实现：使用组合设计模式来实现"></a>讨论实现：使用组合设计模式来实现</h2><p>Wikipedia对组合设计模式（Composite pattern）的介绍如下：</p>
<blockquote>
<p>In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to “compose” objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.</p>
</blockquote>
<p>在功能上，SDK的各个功能是由各个子模块的功能所组成的。在程序结构上，SDK的主类对象也可以是由多个子模块的对象所组成。成员类型可以是Inteface或者抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class AppLogSDKImpl &#123;</span><br><span class="line">   &#x2F;&#x2F; instance properties</span><br><span class="line">   AppLogDAOInteface dao,</span><br><span class="line">   AppLogReportServiceInteface reportService,</span><br><span class="line">   AppLogAppLifeCycleTrackInteface lifeCycleTrack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.zlrs.site/mweb/2021/08/14/16289382645371.jpg" alt="组合设计模式形成的树形成员关系图"></p>
<p>相比单例，这带来了以下好处</p>
<ul>
<li>方便搞清类间依赖关系。只需要阅读类的接口代码，就能知道其依赖。相关工具的开发也因此简便。</li>
<li>方便单元测试。子模块的对象作为主类对象的成员，可以应用接口抽象、继承或者依赖注入，便于被测试用例mock。每个类都可以被轻松地剥离出应用，并在注入mock依赖后成为一个独立的子系统。</li>
<li>有助于维护单一职责模型。由于无法被当做全局变量使用，就不会有人出于偷懒，把一些职责挂载到其它对象上。</li>
<li>功能更强大，能更好地应对需求变更。</li>
</ul>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>熟悉面向对象不仅仅是熟悉面向对象语言的关键词和语法而已，更重要的是</p>
<ul>
<li>在语言无关的层面熟悉面向对象的思想</li>
<li>了解设计模式和对象关系图（类成员依赖关系图、对象创建关系图、函数调用关系图）</li>
<li>多写代码，多看好的代码</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/137975/what-are-drawbacks-or-disadvantages-of-singleton-pattern">What are drawbacks or disadvantages of singleton pattern?</a></li>
<li><a target="_blank" rel="noopener" href="https://testing.googleblog.com/2008/08/by-miko-hevery-so-you-join-new-project.html">Singletons are Pathological Liars</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-探索Xcode命令行工具系统（二）：git命令的调用过程" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-06T14:39:55.000Z"><a href="/2021/08/06/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Agit%E5%91%BD%E4%BB%A4%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/">2021-08-06</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/06/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Agit%E5%91%BD%E4%BB%A4%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/">探索Xcode命令行工具系统（二）：git命令的调用过程</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>上一节我们介绍了Xcode和Command Line Tools。<code>git</code>是Command Line Tools的一部分（更准确地说，是其中BSD Tools的一部分）。这一节我们通过<code>git</code>命令来追踪Command Line Tools是怎么调用的。</p>
<p>直接查看git命令的位置，可以发现是位于<code>/usr/bin/git</code>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zlrs@C02D ~&#x2F;B&#x2F;P&#x2F;b&#x2F;t&#x2F;tulsi (master)&gt; which git </span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;git</span><br><span class="line">zlrs@C02D ~&#x2F;B&#x2F;P&#x2F;b&#x2F;t&#x2F;tulsi (master)&gt; ls -l (which git)</span><br><span class="line">-rwxr-xr-x  1 root  wheel  137616  1  1  2020 &#x2F;usr&#x2F;bin&#x2F;git</span><br></pre></td></tr></table></figure>
<p>但是，在未安装Command Line Tools的情况下，虽然<code>/usr/bin/git</code>存在，但是依然无法使用git的。如果调用git，将提示未安装Command Line Tools并exit。</p>
<p>实际上<code>/usr/bin/git</code>并非真实的git程序。<code>/usr/bin/git</code>只是一个桩，实际上是调用xcrun去执行当前Xcode Developer directory中的git（如<code>/Applications/Xcode.app/Contents/Developer/usr/bin/git</code>）. </p>
<p>做一个简单的实验，通过DEVELOPER_DIR环境变量指定Xcode Developer directory之后，可以发现xcrun无法找到真正的git命令的路径。<br><img src="https://cdn.zlrs.site/mweb/2021/08/06/16282457725258.jpg" alt="-w734"></p>
<p>这一点也可以通过追踪<code>/usr/bin/git</code>的系统调用来验证。追踪前需要先移除桩二进制的签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;usr&#x2F;bin&#x2F;git .&#x2F;</span><br><span class="line">sudo codesign --remove-signature .&#x2F;git</span><br><span class="line">sudo dtruss .&#x2F;git -h</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.zlrs.site/mweb/2021/08/06/16282465341716.jpg" alt="-w1625"></p>
<p><img src="https://cdn.zlrs.site/mweb/2021/08/06/16282465142731.jpg" alt="-w1481"></p>
<p>完整代码见<a target="_blank" rel="noopener" href="https://gist.github.com/zlrs/4aa3f284eb0cb23fb2e1da0b16945814">gist</a>. </p>
<script src="https://gist.github.com/zlrs/4aa3f284eb0cb23fb2e1da0b16945814.js"></script>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-探索Xcode命令行工具系统（一）：Xcode和Command-Line-Tools介绍" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-06T14:38:57.000Z"><a href="/2021/08/06/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AXcode%E5%92%8CCommand-Line-Tools%E4%BB%8B%E7%BB%8D/">2021-08-06</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/06/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AXcode%E5%92%8CCommand-Line-Tools%E4%BB%8B%E7%BB%8D/">探索Xcode命令行工具系统（一）：Xcode和Command Line Tools介绍</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>本来标题想用「探索Xcode命令行生态」的，想想“生态”一词用在这里略显浮夸，就改成了“系统”（还有个原因，应该是受到了最近在看的<a target="_blank" rel="noopener" href="https://book.douban.com/subject/11528220/">“系统之美”</a>这本书的影响）。加上“工具”一词，是为了与”Command Line Tools”一词对译。</p>
<p>Xcode是苹果提供的用于开发运行于macOS, iPhone, iPad, Apple Watch, Apple TV等硬件平台上的软件的开发工具集。它不仅是Xcode IDE，也包括了iOS模拟器、iOS真机调试软件、各硬件平台SDK、Command Line Tools等等所有开发必须的软件。</p>
<p>Command Line Tools的全称是 Command Line Tools for Xcode x.x.x，其中x.x.x是Xcode的版本。Command Line Tools包含有LLVM toolchain、git、macOS SDK等软件，是开发的必需品。它可以随Xcode分发，也可以单独下载和使用（即不需要安装Xcode）。可能是出于减小包大小和简化发版的原因，最近的Xcode.app已不在自带Command Line Tools。开发者在第一次打开Xcode时，会跳出安装Command Line Tools的提示框。<br>其他安装Command Line Tools的方法还有：</p>
<ul>
<li><code>sudo xcode-select --install</code></li>
<li>单独下载并安装</li>
<li>在Xcode GUI中安装</li>
</ul>
<p>小结：Xcode和Command Line Tools的关系是：Command Line Tools是Xcode的一部分，但是完全可以单独使用。比如你可以在mac构建机上不安装Xcode APP，只安装Command Line Tools。</p>
<p>为了减少大家每一篇的阅读时间，我把这个系列分成了5篇（暂定）。在下一篇文章里，我将通过探索<code>git -h</code>命令运行的例子，来正式开启我们这个系列的学习。<br><img src="https://cdn.zlrs.site/mweb/2021/08/06/16282399579998.jpg" alt="-w1302"></p>
<p>Reference:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/download/all/">苹果开发者下载中心</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-NSURLRequest网络调试技巧" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-02-07T00:00:00.000Z"><a href="/2021/02/07/NSURLRequest%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">2021-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2021/02/07/NSURLRequest%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">NSURLRequest网络调试技巧</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h2><ol>
<li>本文提供了一个<code>NSURLRequest</code>分类，便于在运行时捕获URL请求对象的请求信息。</li>
<li>本文介绍了VSCode插件<code>REST Client</code>的使用方法。</li>
<li>本文介绍了如何将上面两者配合使用，从而方便iOS/macOS客户端同学调试网络请求。</li>
</ol>
<p>这个方法原理是先把NSURLRequest以「HTTP格式」或「cURL格式」打印出来，然后利用VSCode的「REST Client」插件或者终端随时修改请求内容，便于调试请求。</p>
<h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><ol>
<li> 在客户端代码中添加下面的分类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSURLRequest (DEBUG)</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line"></span><br><span class="line">&#x2F;* 生成VSCode「REST Client」插件所需要的请求格式（HTTP 语言） *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString *)debug_VSCodeRESTClientPlugin_HTTP &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *result &#x3D; [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;%@ %@ %@\n&quot;, self.HTTPMethod, self.URL.absoluteString, @&quot;HTTP&#x2F;1.1&quot;]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NSDictionary *fields &#x3D; self.allHTTPHeaderFields;</span><br><span class="line"></span><br><span class="line">    for (NSString *headerName in fields) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *headerVal &#x3D; fields[headerName];</span><br><span class="line"></span><br><span class="line">        [result appendString:[NSString stringWithFormat:@&quot;%@: %@\n&quot;, headerName, headerVal]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    NSString *body &#x3D; [[NSString alloc] initWithData:self.HTTPBody encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;\n%@\n\n###&quot;, body]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 生成VSCode「REST Client」插件所需要的请求格式（cURL 格式） *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString *)debug_VSCodeRESTClientPlugin_cURL &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *result &#x3D; [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;curl -i -X %@ &quot;, self.HTTPMethod]];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;\&quot;%@\&quot; &quot;, self.URL.absoluteString]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NSDictionary *fields &#x3D; self.allHTTPHeaderFields;</span><br><span class="line"></span><br><span class="line">    for (NSString *headerName in fields) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *headerVal &#x3D; fields[headerName];</span><br><span class="line"></span><br><span class="line">        [result appendString:[NSString stringWithFormat:@&quot;-H \&quot;%@: %@\&quot; &quot;, headerName, headerVal]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    NSString *body &#x3D; [[NSString alloc] initWithData:self.HTTPBody encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;-d \&quot;%@\&quot;&quot;, body]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 在VSCode上安装 <strong>REST Client</strong> 插件</li>
</ol>
<p><strong>REST Client</strong> 是一个用于调试网络请求的VSCode插件。其功能和Postman类似。其特点是纯文本操作，不需要用鼠标在GUI上点点点，熟练使用后调试效率较高。</p>
<p><strong>REST Client</strong> 的使用方式非常简单，在VSCode中新建一个<code>.http</code>或<code>.rest</code>拓展名的文件，然后在文件中书写「HTTP格式」或「cURL格式」的请求代码。点击代码头部或右键菜单中的<code>send Request</code>发送请求，就可以在右侧看到响应了。</p>
<p><img src="https://raw.githubusercontent.com/Huachao/vscode-restclient/master/images/response.gif"></p>
<h2 id="使用方法（HTTP-格式）"><a href="#使用方法（HTTP-格式）" class="headerlink" title="使用方法（HTTP 格式）"></a>使用方法（HTTP 格式）</h2><ol>
<li> 在需要调试的地方调用分类方法，把URL请求对象“捕获”下来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; xxx;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [request debug_VSCodeRESTClientPlugin_HTTP]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p> 在VSCode中打开一个http后缀名的文件，把输出的内容贴到xxx.http文件里。<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650141059.jpg"></p>
</li>
<li><p> 在右键菜单中点击 sendRequest，就可以发出请求，并在右侧看到服务端的响应了。<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650346776.jpg"></p>
</li>
<li><p> 如果请求参数需要调整，直接在文件中修改并重新发送请求即可。比如上面的截图中，服务端查询返回的是一个空数组。这时候我们就可以方便地修改请求query，很快就能查看修改后的效果。</p>
</li>
</ol>
<h2 id="使用方法（cURL格式）"><a href="#使用方法（cURL格式）" class="headerlink" title="使用方法（cURL格式）"></a>使用方法（cURL格式）</h2><ol>
<li> 打印cURL格式命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; xxx;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [request debug_VSCodeRESTClientPlugin_cURL]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 可以复制到终端中使用，也可以在VSCode「REST Client」插件中调用。<br>通过终端使用:<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650482513.jpg"><br>通过「REST Client」插件使用：<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650604452.jpg"></li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>目前只考虑到了HTTPBody为文本的情况，如果HTTPBody是二进制就需要自己修改下分类代码。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-inclue-import-and-import-in-Objective-C" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-12-29T20:44:35.000Z"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">2020-12-29</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">#inclue, #import, and @import in Objective-C</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>最近在看WWDC中关于Objective-C的一些视频。正好看到<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>中提到Objective-C modules的内容。正好又联系上最近C++群里讨论比较多的 <code>C++20 modules</code>，感觉可以做个总结~</p>
</blockquote>
<table>
<thead>
<tr>
<th>语法(semantic)</th>
<th>归属模块</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>传统预处理器</td>
<td>文本插入(textual inclusion)，没有别的trick</td>
</tr>
<tr>
<td>#import</td>
<td>Objective-C的预处理器</td>
<td>文本插入。但能保证不重复引入头文件</td>
</tr>
<tr>
<td>@import</td>
<td>Objective-C(iOS 7.0+)</td>
<td>Objective-C modules</td>
</tr>
</tbody></table>
<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><p><code>#include</code>是一个支撑了C系语言几十年的机制。它就是简单的文本插入，没有别的trick。在C语言里，函数声明写在<code>.h</code>头文件中，函数实现写在<code>.c</code>源文件中。<code>#include &quot;xxx.h&quot;</code>就是先把<code>xxx.h</code>的文本插入到<code>#include &quot;xxx.h&quot;</code>所在的位置；如果插入的文本中还有<code>#include</code>就继续插入。<br>它有3个缺点，当然对应的也有workaround。</p>
<h3 id="缺点1：可能重复引入头文件"><a href="#缺点1：可能重复引入头文件" class="headerlink" title="缺点1：可能重复引入头文件"></a>缺点1：可能重复引入头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;  // compile error: redefinition of ‘int add(int, int)’</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="规避方法-workaround"><a href="#规避方法-workaround" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>Header guard.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="comment">// Header Guard有项目名前缀+文件名前缀，是为了避免一不小心把源代码给替换了。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="缺点2：宏替换问题"><a href="#缺点2：宏替换问题" class="headerlink" title="缺点2：宏替换问题"></a>缺点2：宏替换问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE <span class="meta-string">&quot;data.txt&quot;</span>  <span class="comment">// 本来我只想在本文件中使用这个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  // 但是没想到 stdio.h 里的 FILE 也被替换成 &quot;data.txt&quot; 了</span></span></span><br><span class="line"><span class="comment">// 编译器会报一些很难理解的错误。</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">/usr/include/stdio.h:195:34: error: expected constructor, destructor, or type conversion before ‘;’ token</span></span><br><span class="line"><span class="comment"> extern FILE *tmpfile (void) __wur;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 FILE 文件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图：CI 对 Header Guard 过短给出的建议<br><img src="https://cdn.zlrs.site/mweb/2021/07/27/16118301586367.jpg" alt="-w850"></p>
<h4 id="规避方法-workaround-1"><a href="#规避方法-workaround-1" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>每次使用宏时都加上前缀，如项目名等，并且全用大写加下划线（因为一般符号很少全是大写的）。比如<code>#define FILE &quot;data.txt&quot;</code>，替换成<code>#define PROJECTNAME_DATA_FILE &quot;data.txt&quot;</code>。</p>
<h3 id="缺点3：影响编译速度"><a href="#缺点3：影响编译速度" class="headerlink" title="缺点3：影响编译速度"></a>缺点3：影响编译速度</h3><p>(1) 头文件是嵌套<code>#include</code>的。一行普通的<code>#include &lt;stdio.h&gt;</code>，完全展开后可能有几千几万行代码。由于代码量很大，所以编译很耗时。<br>(2) 如果第(1)点的编译耗时是一次性的，那还可以接受。但是工程中有这样的情况: 几乎每个编译单元（源文件）都要引入同一个头文件，比如 <code>UIKit.h</code>。编译单元之间对头文件的编译产物无法复用。假如工程中有M个源文件，N个头文件，则项目的编译最多可以达到 MxN 的复杂度。这样的项目是非拓展性的(unscaleable)。</p>
<h4 id="规避方法-workaround-2"><a href="#规避方法-workaround-2" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>使用pch(precompiled header). pch解决了上面提到的第(2)个问题。程序员将一些共用的头文件写在<code>.pch</code>文件中。<code>.pch</code>中的头文件会被预先编译好，并在每个源文件中默认引入。<code>pch</code>的确提高了编译速度。但是<code>pch</code>由于会被默认引入到每个源文件，这个解法其实很不好，因为它带来了名字空间污染(namespace polution)。</p>
<h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><p><code>#import</code>是Objective-C预处理器引入的一个特性。它仍然是文本插入，但是可以保证同一个编译单元中，同一头文件的内容只被插入一次。<br>更详细的可以看StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/439662/what-is-the-difference-between-import-and-include-in-objective-c">What is the difference between #import and #include in Objective-C?</a>。</p>
<h2 id="import-1"><a href="#import-1" class="headerlink" title="@import"></a>@import</h2><p>我们可以先把目光从C系语言转移到JS、Python等语言。JS和Python都没有头文件，他们遵循的是modules的概念。一般<code>module</code>是一个文件，这个文件<code>export</code>出一些接口；其它文件可以<code>import</code>一个module，从而调用它暴露出来的接口。<br>在python中，我们可以import一个module任意次，而且当Python VM启动之后，只有第一次引入时才会执行module文件，然后把该module缓存到一个哈希表中，随后的引用将直接从哈希表中取得module。JS的<code>require(module)</code>也是类似的原理。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091712656983.jpg" alt="python中可以import一个module任意次"></p>
<p>在iOS7(WWDC 2013)中，苹果为OC引入了modules机制，对应的关键字就是<code>@import</code>。<br>OC的modules有以下特点：</p>
<ol>
<li><p>不是文本插入(textual inclusion). </p>
</li>
<li><p>第二次被<code>@import</code>的module不需要重新编译。大大提高了编译速度。（尤其对于那些不使用或不经常维护<code>pch</code>的项目）</p>
</li>
<li><p>通过<code>modulemap</code>文件关联umbrella头文件和module，并export submodule。顺便我们还可以在<code>modulemap</code>中写link指令，这样就可以自动链接上framework.<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091729424173.jpg" alt="-w849"><br>由于modules的Auto-Link特性，我们的工程在<code>Build Phases</code>中不需要引入<code>UIKit.framwork</code>, <code>Foundation.framwork</code>等依赖。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091731649362.jpg" alt="-w856"></p>
</li>
<li><p>header is the truth。编译器最后做了什么，最后还是看header。类的接口也是依然写在header中，而不是<code>export</code>出来。</p>
</li>
<li><p>Xcode 新项目默认开启modules。现有项目(iOS 7.0+)一般都开启了这个功能。开启后，若该头文件能通过modulemap对应到某个module，则这条<code>#import</code>会被视做<code>@import</code>。因此开发者在OC工程中写的对系统库头文件和Cocoapods组件头文件的<code>#import</code>(如<code>#import &lt;MapKit/MapKit.h&gt;</code>)，大多数情况下已经不是直接的文本插入了，而是被Xcode视作<code>@import</code>(<code>@import MapKit</code>）。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091727588022.jpg" alt="现有项目一般都开启了modules"></p>
</li>
<li><p>我们自己的SDK也可以使用module的特性。看起来cocoapods会帮助我们做这件事。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091734906367.jpg" alt="cocoapods自动生成的modulemap文件"></p>
</li>
</ol>
<p>更详细的可以看<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>和 StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18947516/import-vs-import-ios-7">@import vs #import - iOS 7</a>。</p>
<h2 id="modules-in-C"><a href="#modules-in-C" class="headerlink" title="modules in C++"></a>modules in C++</h2><p>苹果的工程师将OC的这套modules实现借鉴到C++上，并做了在2012年做了一个分享。<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=4Xo9iH5VLQ0">C++ Modules proposal</a>(2012年12月5日)</p>
<p>现在modules已经进入C++20，标准规定和苹果当初提出的方案挺相似的。也是基于<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/Modules.html#module-map-language">modulemap</a>实现的。</p>
<p>有关C++20 modules的更多信息，可以看下面的视频和资料。<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=6SKIUeRaLZE">Demo: C++20 Modules</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FRkJCvHWdwQ&t=232s">C++20: An (Almost) Complete Overview - Marc Gregoire - CppCon 2020</a></p>
<p><a target="_blank" rel="noopener" href="https://mariusbancila.ro/blog/2020/05/15/modules-in-clang-11/">Modules in Clang 11</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33307657/how-do-i-use-c-modules-in-clang">How do I use C++ modules in Clang?</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="zlrs.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/C-C-11/">C++ C++11</a><small>1</small></li>
  
    <li><a href="/tags/Objective-C-runtime/">Objective-C runtime</a><small>1</small></li>
  
    <li><a href="/tags/Objetive-C-%E5%8E%86%E5%8F%B2/">Objetive-C 历史</a><small>1</small></li>
  
    <li><a href="/tags/ProgramDesign/">ProgramDesign</a><small>1</small></li>
  
    <li><a href="/tags/iOS-Objective-C-WWDC/">iOS Objective-C WWDC</a><small>1</small></li>
  
    <li><a href="/tags/macOS-iOS/">macOS iOS</a><small>3</small></li>
  
    <li><a href="/tags/%E7%BD%91%E7%BB%9C-iOS-macOS/">网络 iOS macOS</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2024 zlrs
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
