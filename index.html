<!DOCTYPE HTML>
<html lang="zh_CN">
<head>
  <meta charset="utf-8">
  
  <title>zlrs - blog</title>
  <meta name="author" content="zlrs">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="zlrs - blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">zlrs - blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-NSURLRequest网络调试技巧" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-07-28T18:39:34.000Z"><a href="/2021/07/28/NSURLRequest%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">2021-07-28</a></time>
      
      
  
    <h1 class="title"><a href="/2021/07/28/NSURLRequest%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">NSURLRequest网络调试技巧</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h2><ol>
<li>本文提供了一个<code>NSURLRequest</code>分类，便于在运行时捕获URL请求对象的请求信息。</li>
<li>本文介绍了VSCode插件<code>REST Client</code>的使用方法。</li>
<li>本文介绍了如何将上面两者配合使用，从而方便iOS/macOS客户端同学调试网络请求。</li>
</ol>
<p>这个方法原理是先把NSURLRequest以「HTTP格式」或「cURL格式」打印出来，然后利用VSCode的「REST Client」插件或者终端随时修改请求内容，便于调试请求。</p>
<h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><ol>
<li> 在客户端代码中添加下面的分类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSURLRequest (DEBUG)</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line"></span><br><span class="line">&#x2F;* 生成VSCode「REST Client」插件所需要的请求格式（HTTP 语言） *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString *)debug_VSCodeRESTClientPlugin_HTTP &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *result &#x3D; [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;%@ %@ %@\n&quot;, self.HTTPMethod, self.URL.absoluteString, @&quot;HTTP&#x2F;1.1&quot;]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NSDictionary *fields &#x3D; self.allHTTPHeaderFields;</span><br><span class="line"></span><br><span class="line">    for (NSString *headerName in fields) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *headerVal &#x3D; fields[headerName];</span><br><span class="line"></span><br><span class="line">        [result appendString:[NSString stringWithFormat:@&quot;%@: %@\n&quot;, headerName, headerVal]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    NSString *body &#x3D; [[NSString alloc] initWithData:self.HTTPBody encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;\n%@\n\n###&quot;, body]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 生成VSCode「REST Client」插件所需要的请求格式（cURL 格式） *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString *)debug_VSCodeRESTClientPlugin_cURL &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *result &#x3D; [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;curl -i -X %@ &quot;, self.HTTPMethod]];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;\&quot;%@\&quot; &quot;, self.URL.absoluteString]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NSDictionary *fields &#x3D; self.allHTTPHeaderFields;</span><br><span class="line"></span><br><span class="line">    for (NSString *headerName in fields) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *headerVal &#x3D; fields[headerName];</span><br><span class="line"></span><br><span class="line">        [result appendString:[NSString stringWithFormat:@&quot;-H \&quot;%@: %@\&quot; &quot;, headerName, headerVal]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    NSString *body &#x3D; [[NSString alloc] initWithData:self.HTTPBody encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;-d \&quot;%@\&quot;&quot;, body]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 在VSCode上安装 <strong>REST Client</strong> 插件</li>
</ol>
<p><strong>REST Client</strong> 是一个用于调试网络请求的VSCode插件。其功能和Postman类似。其特点是纯文本操作，不需要用鼠标在GUI上点点点，熟练使用后调试效率较高。</p>
<p><strong>REST Client</strong> 的使用方式非常简单，在VSCode中新建一个<code>.http</code>或<code>.rest</code>拓展名的文件，然后在文件中书写「HTTP格式」或「cURL格式」的请求代码。点击代码头部或右键菜单中的<code>send Request</code>发送请求，就可以在右侧看到响应了。</p>
<p><img src="https://raw.githubusercontent.com/Huachao/vscode-restclient/master/images/response.gif"></p>
<h2 id="使用方法（HTTP-格式）"><a href="#使用方法（HTTP-格式）" class="headerlink" title="使用方法（HTTP 格式）"></a>使用方法（HTTP 格式）</h2><ol>
<li> 在需要调试的地方调用分类方法，把URL请求对象“捕获”下来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; xxx;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [request debug_VSCodeRESTClientPlugin_HTTP]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p> 在VSCode中打开一个http后缀名的文件，把输出的内容贴到xxx.http文件里。<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650141059.jpg"></p>
</li>
<li><p> 在右键菜单中点击 sendRequest，就可以发出请求，并在右侧看到服务端的响应了。<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650346776.jpg"></p>
</li>
<li><p> 如果请求参数需要调整，直接在文件中修改并重新发送请求即可。比如上面的截图中，服务端查询返回的是一个空数组。这时候我们就可以方便地修改请求query，很快就能查看修改后的效果。</p>
</li>
</ol>
<h2 id="使用方法（cURL格式）"><a href="#使用方法（cURL格式）" class="headerlink" title="使用方法（cURL格式）"></a>使用方法（cURL格式）</h2><ol>
<li> 打印cURL格式命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; xxx;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [request debug_VSCodeRESTClientPlugin_cURL]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 可以复制到终端中使用，也可以在VSCode「REST Client」插件中调用。<br>通过终端使用:<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650482513.jpg"><br>通过「REST Client」插件使用：<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650604452.jpg"></li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>目前只考虑到了HTTPBody为文本的情况，如果HTTPBody是二进制就需要自己修改下分类代码。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-inclue-import-and-import-in-Objective-C" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-12-29T20:44:35.000Z"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">2020-12-29</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">#inclue, #import, and @import in Objective-C</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>最近在看WWDC中关于Objective-C的一些视频。正好看到<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>中提到Objective-C modules的内容。正好又联系上最近C++群里讨论比较多的 <code>C++20 modules</code>，感觉可以做个总结~</p>
</blockquote>
<table>
<thead>
<tr>
<th>语法(semantic)</th>
<th>归属模块</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>传统预处理器</td>
<td>文本插入(textual inclusion)，没有别的trick</td>
</tr>
<tr>
<td>#import</td>
<td>Objective-C的预处理器</td>
<td>文本插入。但能保证不重复引入头文件</td>
</tr>
<tr>
<td>@import</td>
<td>Objective-C(iOS 7.0+)</td>
<td>Objective-C modules</td>
</tr>
</tbody></table>
<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><p><code>#include</code>是一个支撑了C系语言几十年的机制。它就是简单的文本插入，没有别的trick。在C语言里，函数声明写在<code>.h</code>头文件中，函数实现写在<code>.c</code>源文件中。<code>#include &quot;xxx.h&quot;</code>就是先把<code>xxx.h</code>的文本插入到<code>#include &quot;xxx.h&quot;</code>所在的位置；如果插入的文本中还有<code>#include</code>就继续插入。<br>它有3个缺点，当然对应的也有workaround。</p>
<h3 id="缺点1：可能重复引入头文件"><a href="#缺点1：可能重复引入头文件" class="headerlink" title="缺点1：可能重复引入头文件"></a>缺点1：可能重复引入头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;  // compile error: redefinition of ‘int add(int, int)’</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="规避方法-workaround"><a href="#规避方法-workaround" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>Header guard.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="comment">// Header Guard有项目名前缀+文件名前缀，是为了避免一不小心把源代码给替换了。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="缺点2：宏替换问题"><a href="#缺点2：宏替换问题" class="headerlink" title="缺点2：宏替换问题"></a>缺点2：宏替换问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE <span class="meta-string">&quot;data.txt&quot;</span>  <span class="comment">// 本来我只想在本文件中使用这个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  // 但是没想到 stdio.h 里的 FILE 也被替换成 &quot;data.txt&quot; 了</span></span></span><br><span class="line"><span class="comment">// 编译器会报一些很难理解的错误。</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">/usr/include/stdio.h:195:34: error: expected constructor, destructor, or type conversion before ‘;’ token</span></span><br><span class="line"><span class="comment"> extern FILE *tmpfile (void) __wur;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 FILE 文件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图：CI 对 Header Guard 过短给出的建议<br><img src="https://cdn.zlrs.site/mweb/2021/07/27/16118301586367.jpg" alt="-w850"></p>
<h4 id="规避方法-workaround-1"><a href="#规避方法-workaround-1" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>每次使用宏时都加上前缀，如项目名等，并且全用大写加下划线（因为一般符号很少全是大写的）。比如<code>#define FILE &quot;data.txt&quot;</code>，替换成<code>#define PROJECTNAME_DATA_FILE &quot;data.txt&quot;</code>。</p>
<h3 id="缺点3：影响编译速度"><a href="#缺点3：影响编译速度" class="headerlink" title="缺点3：影响编译速度"></a>缺点3：影响编译速度</h3><p>(1) 头文件是嵌套<code>#include</code>的。一行普通的<code>#include &lt;stdio.h&gt;</code>，完全展开后可能有几千几万行代码。由于代码量很大，所以编译很耗时。<br>(2) 如果第(1)点的编译耗时是一次性的，那还可以接受。但是工程中有这样的情况: 几乎每个编译单元（源文件）都要引入同一个头文件，比如 <code>UIKit.h</code>。编译单元之间对头文件的编译产物无法复用。假如工程中有M个源文件，N个头文件，则项目的编译最多可以达到 MxN 的复杂度。这样的项目是非拓展性的(unscaleable)。</p>
<h4 id="规避方法-workaround-2"><a href="#规避方法-workaround-2" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>使用pch(precompiled header). pch解决了上面提到的第(2)个问题。程序员将一些共用的头文件写在<code>.pch</code>文件中。<code>.pch</code>中的头文件会被预先编译好，并在每个源文件中默认引入。<code>pch</code>的确提高了编译速度。但是<code>pch</code>由于会被默认引入到每个源文件，这个解法其实很不好，因为它带来了名字空间污染(namespace polution)。</p>
<h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><p><code>#import</code>是Objective-C预处理器引入的一个特性。它仍然是文本插入，但是可以保证同一个编译单元中，同一头文件的内容只被插入一次。<br>更详细的可以看StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/439662/what-is-the-difference-between-import-and-include-in-objective-c">What is the difference between #import and #include in Objective-C?</a>。</p>
<h2 id="import-1"><a href="#import-1" class="headerlink" title="@import"></a>@import</h2><p>我们可以先把目光从C系语言转移到JS、Python等语言。JS和Python都没有头文件，他们遵循的是modules的概念。一般<code>module</code>是一个文件，这个文件<code>export</code>出一些接口；其它文件可以<code>import</code>一个module，从而调用它暴露出来的接口。<br>在python中，我们可以import一个module任意次，而且当Python VM启动之后，只有第一次引入时才会执行module文件，然后把该module缓存到一个哈希表中，随后的引用将直接从哈希表中取得module。JS的<code>require(module)</code>也是类似的原理。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091712656983.jpg" alt="python中可以import一个module任意次"></p>
<p>在iOS7(WWDC 2013)中，苹果为OC引入了modules机制，对应的关键字就是<code>@import</code>。<br>OC的modules有以下特点：</p>
<ol>
<li><p>不是文本插入(textual inclusion). </p>
</li>
<li><p>第二次被<code>@import</code>的module不需要重新编译。大大提高了编译速度。（尤其对于那些不使用或不经常维护<code>pch</code>的项目）</p>
</li>
<li><p>通过<code>modulemap</code>文件关联umbrella头文件和module，并export submodule。顺便我们还可以在<code>modulemap</code>中写link指令，这样就可以自动链接上framework.<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091729424173.jpg" alt="-w849"><br>由于modules的Auto-Link特性，我们的工程在<code>Build Phases</code>中不需要引入<code>UIKit.framwork</code>, <code>Foundation.framwork</code>等依赖。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091731649362.jpg" alt="-w856"></p>
</li>
<li><p>header is the truth。编译器最后做了什么，最后还是看header。类的接口也是依然写在header中，而不是<code>export</code>出来。</p>
</li>
<li><p>Xcode 新项目默认开启modules。现有项目(iOS 7.0+)一般都开启了这个功能。开启后，若该头文件能通过modulemap对应到某个module，则这条<code>#import</code>会被视做<code>@import</code>。因此开发者在OC工程中写的对系统库头文件和Cocoapods组件头文件的<code>#import</code>(如<code>#import &lt;MapKit/MapKit.h&gt;</code>)，大多数情况下已经不是直接的文本插入了，而是被Xcode视作<code>@import</code>(<code>@import MapKit</code>）。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091727588022.jpg" alt="现有项目一般都开启了modules"></p>
</li>
<li><p>我们自己的SDK也可以使用module的特性。看起来cocoapods会帮助我们做这件事。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091734906367.jpg" alt="cocoapods自动生成的modulemap文件"></p>
</li>
</ol>
<p>更详细的可以看<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>和 StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18947516/import-vs-import-ios-7">@import vs #import - iOS 7</a>。</p>
<h2 id="modules-in-C"><a href="#modules-in-C" class="headerlink" title="modules in C++"></a>modules in C++</h2><p>苹果的工程师将OC的这套modules实现借鉴到C++上，并做了在2012年做了一个分享。<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=4Xo9iH5VLQ0">C++ Modules proposal</a>(2012年12月5日)</p>
<p>现在modules已经进入C++20，标准规定和苹果当初提出的方案挺相似的。也是基于<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/Modules.html#module-map-language">modulemap</a>实现的。</p>
<p>有关C++20 modules的更多信息，可以看下面的视频和资料。<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=6SKIUeRaLZE">Demo: C++20 Modules</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FRkJCvHWdwQ&t=232s">C++20: An (Almost) Complete Overview - Marc Gregoire - CppCon 2020</a></p>
<p><a target="_blank" rel="noopener" href="https://mariusbancila.ro/blog/2020/05/15/modules-in-clang-11/">Modules in Clang 11</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33307657/how-do-i-use-c-modules-in-clang">How do I use C++ modules in Clang?</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="zlrs.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/iOS-Objective-C-WWDC/">iOS Objective-C WWDC</a><small>1</small></li>
  
    <li><a href="/tags/%E7%BD%91%E7%BB%9C-iOS-macOS/">网络 iOS macOS</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 zlrs
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
