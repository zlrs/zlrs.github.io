<!DOCTYPE HTML>
<html lang="zh_CN">
<head>
  <meta charset="utf-8">
  
  <title>zlrs - blog</title>
  <meta name="author" content="zlrs">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="zlrs - blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">zlrs - blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-C-11中的移动语义" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-09-09T21:19:29.000Z"><a href="/2021/09/09/C-11%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/">2021-09-09</a></time>
      
      
  
    <h1 class="title"><a href="/2021/09/09/C-11%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/">C++11中的移动语义</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="引入移动语义（move-semantics）的背景"><a href="#引入移动语义（move-semantics）的背景" class="headerlink" title="引入移动语义（move semantics）的背景"></a>引入移动语义（move semantics）的背景</h2><p>C++03（及之前）禁止修改临时对象。然而，在一些情况下，临时对象是可以被修改的。（这里可以的意思是，理论上可以做到这一点，但是语言未实现此操作）。并且如果支持修改临时对象，在某些场合，就不必通过copy ctor构造新对象（这会造成对资源的深拷贝），而是“偷走”临时对象的资源，这可以提高效率。</p>
<p>为了实现这一点，C++需要提供一种新的构造函数和赋值操作符函数。而为了提供这类函数，C++必须增加一种新的型别。</p>
<p>因此C++11引入了右值引用这一型别，用来指代（refer to）一个可以被修改的临时对象。同时增加了std::move，用于将一个值的型别强转为右值引用。同时增加了移动构造函数和移动赋值操作符函数。</p>
<p>在这篇文章里，我们首先观察C++11提供的各种型别，并重点理解右值引用。然后我们会探索<code>std::move</code>的实现。最后文章提供了一个简单的Demo，说明C++11引入移动语义的动机。</p>
<h2 id="C-11型别"><a href="#C-11型别" class="headerlink" title="C++11型别"></a>C++11型别</h2><ul>
<li>左值（lvalue）<ul>
<li>有人称之为“有位置的值”（能取地址）或“有名字的值”。</li>
<li><code>int x = 5;</code>中的x。能对x取地址，所以x是左值。</li>
</ul>
</li>
<li>右值（rvalue）<ul>
<li>纯右值（Pure Rvalue，即C++98中的右值）<ul>
<li>临时变量、不与名字关联的字面量值。</li>
<li><code>int x = 5;</code> 中的5. 5（在语言层面上）不具有内存地址，是右值。</li>
<li><code>true</code>/<code>false</code></li>
<li><code>x+1</code></li>
</ul>
</li>
<li>临终值（xvalue）</li>
</ul>
</li>
<li>临终值（xvalue, eXpiring Value）（C++11引入）<ul>
<li>临终值的意思是，该对象即将停止使用，并且可以被移走内容。</li>
<li>临终值不是左值，因为不能取地址。</li>
<li>临终值不是纯右值，因为可以有名字（identity）。（可以参考 <a target="_blank" rel="noopener" href="https://riptutorial.com/cplusplus/example/2604/xvalue">C++ Tutorial =&gt; xvalue</a>）</li>
<li>C++11标准把临终值与左值合称为广义左值，即指向某个物理存在的对象；把临终值与纯右值（对应C++03时的右值概念）合称为右值（C++11重新定义的概念），其内容可以移走（该右值生命期到此为止，此后将不再使用）。</li>
</ul>
</li>
<li>左值引用<ul>
<li>对左值的引用</li>
</ul>
</li>
<li>右值引用（C++11引入）<ul>
<li>对右值的引用</li>
<li>用于支持C++11的移动语义和完美转发</li>
</ul>
</li>
<li>cv (const and volatile) type qualifiers</li>
<li>万能引用（universal reference）<ul>
<li>可以被绑定到左值或右值</li>
<li>If a variable or parameter is declared to have type T&amp;&amp; for some deduced type T, that variable or parameter is a universal reference.</li>
<li>在实践当中，几乎所有的universal references都是函数模板的参数。因为auto声明的变量的类型推导规则本质上和模板是一样的，所以使用auto的时候你也可能得到一个universal references。使用typedef和decltype的时候也可能会出现universal references。</li>
</ul>
</li>
</ul>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>一个做类型转换的模板函数。将一个值作为std::move的参数的含义是，告诉编译器这个参数是一个可以被“移动”（偷走资源）的对象，暗示这个对象是一个临时对象或之后不会被使用的对象，因此被偷走资源也没有关系。<br>伪代码: </p>
<blockquote>
<p>右值引用（去除引用（参数））</p>
</blockquote>
<p>示例实现（与STL的实现在原理上一致）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename remove_reference&lt;T&gt;::type&amp;&amp;</span><br><span class="line">move(T&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    using ReturnType &#x3D; typename remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    return static_cast&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Demo：自定义String类的移动构造函数"><a href="#Demo：自定义String类的移动构造函数" class="headerlink" title="Demo：自定义String类的移动构造函数"></a>Demo：自定义String类的移动构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// default ctor</span></span><br><span class="line">  String() = <span class="keyword">default</span>;</span><br><span class="line">   </span><br><span class="line">  String(<span class="keyword">const</span> <span class="keyword">char</span> *c_str) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(c_str);</span><br><span class="line">    m_size = size;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_data, c_str, size);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// copy ctor</span></span><br><span class="line">  String(<span class="keyword">const</span> String &amp;other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Copyed!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">size_t</span> size = other.m_size;</span><br><span class="line">    m_size = size;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_data, other.m_data, size);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // move ctor</span></span><br><span class="line"><span class="comment">  String(String &amp;&amp;other) noexcept &#123;</span></span><br><span class="line"><span class="comment">    printf(&quot;Moved!\n&quot;);</span></span><br><span class="line"><span class="comment">    // steal resources!</span></span><br><span class="line"><span class="comment">    m_data = other.m_data;</span></span><br><span class="line"><span class="comment">    m_size = other.m_size;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    other.m_data = nullptr;</span></span><br><span class="line"><span class="comment">    other.m_size = 0;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  ~String() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Destroyed %zu bytes data at %p!\n&quot;</span>, m_size, m_data);</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_size; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, m_data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span> *m_data;</span><br><span class="line">  <span class="keyword">size_t</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Entity(<span class="keyword">const</span> String &amp;name): m_name(name) &#123;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Entity(String &amp;&amp;name): m_name(std::move(name)) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_name.Print();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  String m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This program demonstrates the motivation of move semantics</span></span><br><span class="line">  <span class="comment">// 解除掉String类和Entity类的两个以右值引用为形参的构造函数的注释，再试试</span></span><br><span class="line">  <span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Effective Modern C++</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3106110/what-is-move-semantics">What is move semantics?</a></li>
<li><a target="_blank" rel="noopener" href="https://riptutorial.com/cplusplus/example/2604/xvalue">C++ Tutorial =&gt; xvalue</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-探索Xcode命令行工具系统（三）：切换Toolchain（介绍xcode-select和xcrun）" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-31T11:12:34.000Z"><a href="/2021/08/31/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%87%E6%8D%A2Toolchain%EF%BC%88%E4%BB%8B%E7%BB%8Dxcode-select%E5%92%8Cxcrun%EF%BC%89/">2021-08-31</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/31/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%87%E6%8D%A2Toolchain%EF%BC%88%E4%BB%8B%E7%BB%8Dxcode-select%E5%92%8Cxcrun%EF%BC%89/">探索Xcode命令行工具系统（三）：切换Toolchain（介绍xcode-select和xcrun）</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>Mac上的每个Xcode APP都内置了一套工具链。工具链也可以单独下载，并部署在单独的文件夹中（如公司AppHealth团队维护的toolchain）。因此，一台Mac上可能存在多套工具链。</p>
<blockquote>
<p>注：下面会混用toolchain和Command Line Tools两种说法。Command Line Tools包含了toolchain。</p>
</blockquote>
<p>为了便于Toolchain的切换，苹果做了如下事情：</p>
<ol>
<li>提供“桩命令”. 具体什么是”桩命令”，可以参考<strong>探索Xcode命令行工具系统（二）：git命令的调用过程</strong>。 举个例子，<code>/usr/bin/git</code>和<code>/usr/bin/clang</code>都是桩命令，对他们的调用实际上是调用到当前toolchain中的对应命令。</li>
<li>提供<code>xcode-select</code>命令和<code>DEVELOPER_DIR</code>环境变量，用于指定当前toolchain</li>
<li>提供<code>xcrun</code>，用于运行当前toolchain中的命令或者打印该命令的路径。</li>
</ol>
<h2 id="xcode-select介绍"><a href="#xcode-select介绍" class="headerlink" title="xcode-select介绍"></a>xcode-select介绍</h2><p>这里简单介绍下参数和用法，具体用法可以看命令的manpage。</p>
<ol>
<li><code>-p</code>参数：打印当前toolchain路径。</li>
<li><code>-s</code>参数：指定系统级toolchain路径。需要<code>sudo</code>权限。将影响本机上所有的用户。</li>
<li><code>DEVELOPER_DIR</code>环境变量：用于指定当前环境的toolchain路径。可以覆盖系统级别的toolchain路径。</li>
</ol>
<p>toolchain的路径一般在Xcode APP中，如<code>/Application/Xcode.app/Contents/Developer</code>（也可以写成<code>/Application/Xcode.app</code>，<code>xcode-select</code>会自动添加后面的部分）. 或者单独存在。</p>
<p>开发者也可以在Xcode IDE中切换系统级的toolchain（Command Line Tools）. 切换时需要指纹验证来获取sudo权限。其底层应该也是通过调用<code>xcode-select</code>实现。<br><img src="https://cdn.zlrs.site/mweb/2021/08/31/16285887284120.jpg" alt="-w942"></p>
<p><strong>配合桩命令和<code>xcode-select</code>，就可以方便地切换toolchain。</strong><br>举个例子：假设我们在编译脚本中存在这样一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild xxx.c -xxxx  # 参数省略</span><br></pre></td></tr></table></figure>
<p>一般来说，<code>xcodebuild</code>会被解析到桩命令<code>/usr/bin/xcodebuild</code>，桩命令再调到当前toolchain的<code>xcodebuild</code>。</p>
<p>问题：如果PATH头部存在其它Toolchain目录，则<code>xcodebuild</code>不会解析到桩命令。<br>如对于以下Path：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=”/Applications/Xcode12.3.app/Contents/Developer/usr/bin:$&#123;PATH&#125;”</span><br></pre></td></tr></table></figure>
<p><code>xcodebuild</code>被会解析到<code>/Applications/Xcode12.3.app/Contents/Developer/usr/bin/xcodebuild</code>，而不是桩命令，从而无法随toolchain的切换而改变路径。</p>
<h2 id="xcrun-介绍"><a href="#xcrun-介绍" class="headerlink" title="xcrun 介绍"></a>xcrun 介绍</h2><p>这里简单介绍下参数和用法，具体用法可以看命令的manpage。</p>
<ol>
<li>执行当前toolchain的某个命令，如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun git status</span><br></pre></td></tr></table></figure></li>
<li>查找命令的路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhuyuanqing@C02D70XMMD6R ~&#x2F;B&#x2F;tools&gt; xcrun --find clang</span><br><span class="line">&#x2F;Applications&#x2F;Xcode12.3.app&#x2F;Contents&#x2F;Developer&#x2F;Toolchains&#x2F;XcodeDefault.xctoolchain&#x2F;usr&#x2F;bin&#x2F;clang</span><br><span class="line">zhuyuanqing@C02D70XMMD6R ~&#x2F;B&#x2F;tools&gt; xcrun --find git</span><br><span class="line">&#x2F;Applications&#x2F;Xcode12.3.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;git</span><br></pre></td></tr></table></figure>
即使PATH头部存在其它Toolchain目录，<code>xcrun --find xcodebuild</code>依然能解析到当前Toolchain的路径。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ PATH&#x3D;&quot;&#x2F;Applications&#x2F;Xcode12.3.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin:$&#123;PATH&#125;&quot;</span><br><span class="line"></span><br><span class="line">$ which xcodebuild                                                     </span><br><span class="line">&#x2F;Applications&#x2F;Xcode12.3.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;xcodebuild</span><br><span class="line"></span><br><span class="line">$ xcrun --find xcodebuild</span><br><span class="line">&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;xcodebuild</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>我们可以通过<code>xcode-select</code>方便地切换系统Toolchain；用<code>DEVELOPER_DIR</code>环境变量切换当前Shell session的Toolchain。</li>
<li>在编写编译脚本时，有两种编写方法<ol>
<li>使用桩命令（如<code>/usr/bin/xcodebuild</code>）运行当前Toolchain中的命令。</li>
<li>使用<code>xcrun</code>运行当前Toolchain中的命令，或<code>xcrun --find</code>在当前Toolchain中查找命令。</li>
</ol>
</li>
</ol>
<p><code>xcrun</code>的工作细节，可以参考<a target="_blank" rel="noopener" href="https://lapcatsoftware.com/articles/xcrun.html">这篇文章</a>.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://support.macincloud.com/support/solutions/articles/8000042681-how-to-utilize-a-different-xcode-version-for-build-process-on-mac">how-to-utilize-a-different-xcode-version-for-build-process-on-mac</a></p>
<p><a target="_blank" rel="noopener" href="https://dive.medium.com/multiple-xcode-versions-or-why-xcrun-is-your-friend-ed3935b054b">multiple-xcode-versions-or-why-xcrun-is-your-friend</a></p>
<p><a target="_blank" rel="noopener" href="https://lapcatsoftware.com/articles/xcrun.html">xcrun details</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-误用单例模式造成的问题（以开发一个SDK为例）" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-14T18:59:01.000Z"><a href="/2021/08/14/%E8%AF%AF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BB%A5%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AASDK%E4%B8%BA%E4%BE%8B%EF%BC%89/">2021-08-14</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/14/%E8%AF%AF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BB%A5%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AASDK%E4%B8%BA%E4%BE%8B%EF%BC%89/">误用单例模式造成的问题（以开发一个SDK为例）</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>这里以开发一个AppLog SDK的例子来说明误用单例模式会造成哪些问题。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>开发的第一步，是确定SDK的功能。我们假设AppLog SDK有以下功能：</p>
<ul>
<li>埋点上报</li>
<li>本次启动未来得及上报的埋点，可以在下次启动时上报</li>
<li>能自动为以下事件做埋点：应用启动、进入前台、进入后台和应用退出</li>
</ul>
<h2 id="细分功能点和讨论软件开发面"><a href="#细分功能点和讨论软件开发面" class="headerlink" title="细分功能点和讨论软件开发面"></a>细分功能点和讨论软件开发面</h2><ul>
<li>埋点上报<ul>
<li>需要一个SDK主类，作为用户界面</li>
</ul>
</li>
<li>本次启动未来得及上报的埋点，可以在下次启动时上报<ul>
<li>埋点数据要持久化到磁盘。需要数据库访问层（DAO）。</li>
<li>需要埋点上报层，并支持不同上报策略（定时上报，手动触发上报等）</li>
</ul>
</li>
<li>能自动为以下事件做埋点：应用启动、进入前台、进入后台和应用退出<ul>
<li>需要一个监听上述生命周期事件的对象</li>
</ul>
</li>
</ul>
<h2 id="讨论实现：完全使用单例模式来实现"><a href="#讨论实现：完全使用单例模式来实现" class="headerlink" title="讨论实现：完全使用单例模式来实现"></a>讨论实现：完全使用单例模式来实现</h2><p>经过以上两步我们分析完了AppLog SDK的功能点，并分出了用户界面层、数据库访问层、上报服务层和应用生命周期埋点层。我简单花了一个层级图表示层间的关系。（这张图不能完全反映软件的真实关系，比如若用户有手动触发上报的需求，则用户页面也需要依赖上报服务的上报接口，从而用户界面画成“L形”会更合适。但是这并不妨碍我们接下来的分析。）</p>
<p> <img src="https://cdn.zlrs.site/mweb/2021/08/14/16289281989139.jpg" alt="我们划分出的软件层级"></p>
<p> 因为每个层最少使用一个对象就可以完成，所以我们很容易想到用每个层都用一个单例。可以定义以下单例：</p>
<ul>
<li>[AppLogSDK sharedInstance]</li>
<li>[AppLogSDKImpl sharedInstance]</li>
<li>[AppLogDAO sharedInstance]</li>
<li>[AppLogReportService sharedInstance]</li>
<li>[AppLogAppLifeCycleTrack sharedInstance]</li>
</ul>
<p>单例之间的通信就是层间通信。5个单例的相互通信实现了埋点数据的流转。这可以让我们的SDK正常工作。但是存在以下代价：</p>
<ol>
<li>单例具有“惯性”。因为后续的开发者会贴近之前代码的实现风格，所以仓库中的单例会随着时间越来越多。可能某个需求用单例实现是不够佳的，但是因为codebase中已经全是单例了，所以后续的开发者往往也会用单例来实现。</li>
<li>难以看清类之间的依赖关系。这是因为单例具有全局名字空间，所以依赖一个单例的对象无需在其接口（成员变量）中声明，而只需要随用随取即可。为了确定依赖，我们不得不去看代码中具体的调用点。（特别是在Objective-C中，一个类的代码可能分布在多个文件，更是令人头疼）这也为静态分析、依赖分析工具的开发增加了难度。当然，作为软件的第一任开发者和依赖关系的最初设计者，你在一开始肯定了解这其中的关系，只是对于新人和N月后再看代码的你来说有难度。</li>
<li>难以编写单元测试。单元测试简单的说就是先确定一个类所有重要的test case，通过mock掉它所有的依赖+并运行被测代码(CUT, Code Under Test)来确定这个类的代码有没有问题。但是由于单例是随用随取的，我们很难去mock CUT对单例的依赖。(在这里例子里，由于AppLogImpl直接依赖了AppLogDAO单例，test case就无从mock数据库依赖)这样我们就无法确定出错时是CUT的错误还是依赖的错误；甚至单测通过时也无法确定是否是“错错得对”。</li>
<li>容易承担过多职责，造成类级别的职责混乱。由于众多单例之间交叉调用的数据流是非常难解读的，而需求紧急时没有足够的时间去了解整个codebase的数据流。这样新人做需求时就容易往已有的单例上添加其他职责，造成职责混乱。</li>
<li>内存占用较高。单例具有静态生命周期，只有在进程退出时才会被析构。当不再需要某个单例时，这个单例也会一直存在，直到进程退出。</li>
<li>较难找到单例的创建时间。要确定单例的创建时间，得先找到所有<code>sharedInstance</code>的调用点，然后在这些调用点中找到时间上最前的那个。当你要为单例注入外部依赖时，弄清这一点是很重要的，否则外部依赖的注入可能晚于单例第一个方法调用。</li>
<li>当未来需求变化时有潜在的巨大改造成本。想象一下，当单例难以满足新增需求时，如需求要求有多个埋点渠道、上报渠道、数据库为了合规也得按渠道隔离；那么单例的设计就会存在很大的改造成本。</li>
</ol>
<h2 id="讨论实现：使用组合设计模式来实现"><a href="#讨论实现：使用组合设计模式来实现" class="headerlink" title="讨论实现：使用组合设计模式来实现"></a>讨论实现：使用组合设计模式来实现</h2><p>Wikipedia对组合设计模式（Composite pattern）的介绍如下：</p>
<blockquote>
<p>In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to “compose” objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.</p>
</blockquote>
<p>在功能上，SDK的各个功能是由各个子模块的功能所组成的。在程序结构上，SDK的主类对象也可以是由多个子模块的对象所组成。成员类型可以是Inteface或者抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class AppLogSDKImpl &#123;</span><br><span class="line">   &#x2F;&#x2F; instance properties</span><br><span class="line">   AppLogDAOInteface dao,</span><br><span class="line">   AppLogReportServiceInteface reportService,</span><br><span class="line">   AppLogAppLifeCycleTrackInteface lifeCycleTrack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.zlrs.site/mweb/2021/08/14/16289382645371.jpg" alt="组合设计模式形成的树形成员关系图"></p>
<p>相比单例，这带来了以下好处</p>
<ul>
<li>方便搞清类间依赖关系。只需要阅读类的接口代码，就能知道其依赖。相关工具的开发也因此简便。</li>
<li>方便单元测试。子模块的对象作为主类对象的成员，可以应用接口抽象、继承或者依赖注入，便于被测试用例mock。每个类都可以被轻松地剥离出应用，并在注入mock依赖后成为一个独立的子系统。</li>
<li>有助于维护单一职责模型。由于无法被当做全局变量使用，就不会有人出于偷懒，把一些职责挂载到其它对象上。</li>
<li>功能更强大，能更好地应对需求变更。</li>
</ul>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>熟悉面向对象不仅仅是熟悉面向对象语言的关键词和语法而已，更重要的是</p>
<ul>
<li>在语言无关的层面熟悉面向对象的思想</li>
<li>了解设计模式和对象关系图（类成员依赖关系图、对象创建关系图、函数调用关系图）</li>
<li>多写代码，多看好的代码</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/137975/what-are-drawbacks-or-disadvantages-of-singleton-pattern">What are drawbacks or disadvantages of singleton pattern?</a></li>
<li><a target="_blank" rel="noopener" href="https://testing.googleblog.com/2008/08/by-miko-hevery-so-you-join-new-project.html">Singletons are Pathological Liars</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-探索Xcode命令行工具系统（二）：git命令的调用过程" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-06T14:39:55.000Z"><a href="/2021/08/06/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Agit%E5%91%BD%E4%BB%A4%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/">2021-08-06</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/06/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Agit%E5%91%BD%E4%BB%A4%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/">探索Xcode命令行工具系统（二）：git命令的调用过程</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>上一节我们介绍了Xcode和Command Line Tools。<code>git</code>是Command Line Tools的一部分（更准确地说，是其中BSD Tools的一部分）。这一节我们通过<code>git</code>命令来追踪Command Line Tools是怎么调用的。</p>
<p>直接查看git命令的位置，可以发现是位于<code>/usr/bin/git</code>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zlrs@C02D ~&#x2F;B&#x2F;P&#x2F;b&#x2F;t&#x2F;tulsi (master)&gt; which git </span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;git</span><br><span class="line">zlrs@C02D ~&#x2F;B&#x2F;P&#x2F;b&#x2F;t&#x2F;tulsi (master)&gt; ls -l (which git)</span><br><span class="line">-rwxr-xr-x  1 root  wheel  137616  1  1  2020 &#x2F;usr&#x2F;bin&#x2F;git</span><br></pre></td></tr></table></figure>
<p>但是，在未安装Command Line Tools的情况下，虽然<code>/usr/bin/git</code>存在，但是依然无法使用git的。如果调用git，将提示未安装Command Line Tools并exit。</p>
<p>实际上<code>/usr/bin/git</code>并非真实的git程序。<code>/usr/bin/git</code>只是一个桩，实际上是调用xcrun去执行当前Xcode Developer directory中的git（如<code>/Applications/Xcode.app/Contents/Developer/usr/bin/git</code>）. </p>
<p>做一个简单的实验，通过DEVELOPER_DIR环境变量指定Xcode Developer directory之后，可以发现xcrun无法找到真正的git命令的路径。<br><img src="https://cdn.zlrs.site/mweb/2021/08/06/16282457725258.jpg" alt="-w734"></p>
<p>这一点也可以通过追踪<code>/usr/bin/git</code>的系统调用来验证。追踪前需要先移除桩二进制的签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv &#x2F;usr&#x2F;bin&#x2F;git .&#x2F;</span><br><span class="line">sudo codesign --remove-signature .&#x2F;git</span><br><span class="line">sudo dtruss .&#x2F;git -h</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.zlrs.site/mweb/2021/08/06/16282465341716.jpg" alt="-w1625"></p>
<p><img src="https://cdn.zlrs.site/mweb/2021/08/06/16282465142731.jpg" alt="-w1481"></p>
<p>完整代码见<a target="_blank" rel="noopener" href="https://gist.github.com/zlrs/4aa3f284eb0cb23fb2e1da0b16945814">gist</a>. </p>
<script src="https://gist.github.com/zlrs/4aa3f284eb0cb23fb2e1da0b16945814.js"></script>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-探索Xcode命令行工具系统（一）：Xcode和Command-Line-Tools介绍" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-06T14:38:57.000Z"><a href="/2021/08/06/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AXcode%E5%92%8CCommand-Line-Tools%E4%BB%8B%E7%BB%8D/">2021-08-06</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/06/%E6%8E%A2%E7%B4%A2Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AXcode%E5%92%8CCommand-Line-Tools%E4%BB%8B%E7%BB%8D/">探索Xcode命令行工具系统（一）：Xcode和Command Line Tools介绍</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>本来标题想用「探索Xcode命令行生态」的，想想“生态”一词用在这里略显浮夸，就改成了“系统”（还有个原因，应该是受到了最近在看的<a target="_blank" rel="noopener" href="https://book.douban.com/subject/11528220/">“系统之美”</a>这本书的影响）。加上“工具”一词，是为了与”Command Line Tools”一词对译。</p>
<p>Xcode是苹果提供的用于开发运行于macOS, iPhone, iPad, Apple Watch, Apple TV等硬件平台上的软件的开发工具集。它不仅是Xcode IDE，也包括了iOS模拟器、iOS真机调试软件、各硬件平台SDK、Command Line Tools等等所有开发必须的软件。</p>
<p>Command Line Tools的全称是 Command Line Tools for Xcode x.x.x，其中x.x.x是Xcode的版本。Command Line Tools包含有LLVM toolchain、git、macOS SDK等软件，是开发的必需品。它可以随Xcode分发，也可以单独下载和使用（即不需要安装Xcode）。可能是出于减小包大小和简化发版的原因，最近的Xcode.app已不在自带Command Line Tools。开发者在第一次打开Xcode时，会跳出安装Command Line Tools的提示框。<br>其他安装Command Line Tools的方法还有：</p>
<ul>
<li><code>sudo xcode-select --install</code></li>
<li>单独下载并安装</li>
<li>在Xcode GUI中安装</li>
</ul>
<p>小结：Xcode和Command Line Tools的关系是：Command Line Tools是Xcode的一部分，但是完全可以单独使用。比如你可以在mac构建机上不安装Xcode APP，只安装Command Line Tools。</p>
<p>为了减少大家每一篇的阅读时间，我把这个系列分成了5篇（暂定）。在下一篇文章里，我将通过探索<code>git -h</code>命令运行的例子，来正式开启我们这个系列的学习。<br><img src="https://cdn.zlrs.site/mweb/2021/08/06/16282399579998.jpg" alt="-w1302"></p>
<p>Reference:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/download/all/">苹果开发者下载中心</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-NSURLRequest网络调试技巧" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-02-07T00:00:00.000Z"><a href="/2021/02/07/NSURLRequest%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">2021-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2021/02/07/NSURLRequest%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">NSURLRequest网络调试技巧</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h2><ol>
<li>本文提供了一个<code>NSURLRequest</code>分类，便于在运行时捕获URL请求对象的请求信息。</li>
<li>本文介绍了VSCode插件<code>REST Client</code>的使用方法。</li>
<li>本文介绍了如何将上面两者配合使用，从而方便iOS/macOS客户端同学调试网络请求。</li>
</ol>
<p>这个方法原理是先把NSURLRequest以「HTTP格式」或「cURL格式」打印出来，然后利用VSCode的「REST Client」插件或者终端随时修改请求内容，便于调试请求。</p>
<h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><ol>
<li> 在客户端代码中添加下面的分类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSURLRequest (DEBUG)</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line"></span><br><span class="line">&#x2F;* 生成VSCode「REST Client」插件所需要的请求格式（HTTP 语言） *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString *)debug_VSCodeRESTClientPlugin_HTTP &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *result &#x3D; [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;%@ %@ %@\n&quot;, self.HTTPMethod, self.URL.absoluteString, @&quot;HTTP&#x2F;1.1&quot;]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NSDictionary *fields &#x3D; self.allHTTPHeaderFields;</span><br><span class="line"></span><br><span class="line">    for (NSString *headerName in fields) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *headerVal &#x3D; fields[headerName];</span><br><span class="line"></span><br><span class="line">        [result appendString:[NSString stringWithFormat:@&quot;%@: %@\n&quot;, headerName, headerVal]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    NSString *body &#x3D; [[NSString alloc] initWithData:self.HTTPBody encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;\n%@\n\n###&quot;, body]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 生成VSCode「REST Client」插件所需要的请求格式（cURL 格式） *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString *)debug_VSCodeRESTClientPlugin_cURL &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *result &#x3D; [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;curl -i -X %@ &quot;, self.HTTPMethod]];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;\&quot;%@\&quot; &quot;, self.URL.absoluteString]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NSDictionary *fields &#x3D; self.allHTTPHeaderFields;</span><br><span class="line"></span><br><span class="line">    for (NSString *headerName in fields) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *headerVal &#x3D; fields[headerName];</span><br><span class="line"></span><br><span class="line">        [result appendString:[NSString stringWithFormat:@&quot;-H \&quot;%@: %@\&quot; &quot;, headerName, headerVal]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    NSString *body &#x3D; [[NSString alloc] initWithData:self.HTTPBody encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;-d \&quot;%@\&quot;&quot;, body]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 在VSCode上安装 <strong>REST Client</strong> 插件</li>
</ol>
<p><strong>REST Client</strong> 是一个用于调试网络请求的VSCode插件。其功能和Postman类似。其特点是纯文本操作，不需要用鼠标在GUI上点点点，熟练使用后调试效率较高。</p>
<p><strong>REST Client</strong> 的使用方式非常简单，在VSCode中新建一个<code>.http</code>或<code>.rest</code>拓展名的文件，然后在文件中书写「HTTP格式」或「cURL格式」的请求代码。点击代码头部或右键菜单中的<code>send Request</code>发送请求，就可以在右侧看到响应了。</p>
<p><img src="https://raw.githubusercontent.com/Huachao/vscode-restclient/master/images/response.gif"></p>
<h2 id="使用方法（HTTP-格式）"><a href="#使用方法（HTTP-格式）" class="headerlink" title="使用方法（HTTP 格式）"></a>使用方法（HTTP 格式）</h2><ol>
<li> 在需要调试的地方调用分类方法，把URL请求对象“捕获”下来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; xxx;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [request debug_VSCodeRESTClientPlugin_HTTP]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p> 在VSCode中打开一个http后缀名的文件，把输出的内容贴到xxx.http文件里。<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650141059.jpg"></p>
</li>
<li><p> 在右键菜单中点击 sendRequest，就可以发出请求，并在右侧看到服务端的响应了。<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650346776.jpg"></p>
</li>
<li><p> 如果请求参数需要调整，直接在文件中修改并重新发送请求即可。比如上面的截图中，服务端查询返回的是一个空数组。这时候我们就可以方便地修改请求query，很快就能查看修改后的效果。</p>
</li>
</ol>
<h2 id="使用方法（cURL格式）"><a href="#使用方法（cURL格式）" class="headerlink" title="使用方法（cURL格式）"></a>使用方法（cURL格式）</h2><ol>
<li> 打印cURL格式命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; xxx;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [request debug_VSCodeRESTClientPlugin_cURL]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 可以复制到终端中使用，也可以在VSCode「REST Client」插件中调用。<br>通过终端使用:<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650482513.jpg"><br>通过「REST Client」插件使用：<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650604452.jpg"></li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>目前只考虑到了HTTPBody为文本的情况，如果HTTPBody是二进制就需要自己修改下分类代码。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-inclue-import-and-import-in-Objective-C" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-12-29T20:44:35.000Z"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">2020-12-29</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">#inclue, #import, and @import in Objective-C</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>最近在看WWDC中关于Objective-C的一些视频。正好看到<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>中提到Objective-C modules的内容。正好又联系上最近C++群里讨论比较多的 <code>C++20 modules</code>，感觉可以做个总结~</p>
</blockquote>
<table>
<thead>
<tr>
<th>语法(semantic)</th>
<th>归属模块</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>传统预处理器</td>
<td>文本插入(textual inclusion)，没有别的trick</td>
</tr>
<tr>
<td>#import</td>
<td>Objective-C的预处理器</td>
<td>文本插入。但能保证不重复引入头文件</td>
</tr>
<tr>
<td>@import</td>
<td>Objective-C(iOS 7.0+)</td>
<td>Objective-C modules</td>
</tr>
</tbody></table>
<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><p><code>#include</code>是一个支撑了C系语言几十年的机制。它就是简单的文本插入，没有别的trick。在C语言里，函数声明写在<code>.h</code>头文件中，函数实现写在<code>.c</code>源文件中。<code>#include &quot;xxx.h&quot;</code>就是先把<code>xxx.h</code>的文本插入到<code>#include &quot;xxx.h&quot;</code>所在的位置；如果插入的文本中还有<code>#include</code>就继续插入。<br>它有3个缺点，当然对应的也有workaround。</p>
<h3 id="缺点1：可能重复引入头文件"><a href="#缺点1：可能重复引入头文件" class="headerlink" title="缺点1：可能重复引入头文件"></a>缺点1：可能重复引入头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;  // compile error: redefinition of ‘int add(int, int)’</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="规避方法-workaround"><a href="#规避方法-workaround" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>Header guard.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="comment">// Header Guard有项目名前缀+文件名前缀，是为了避免一不小心把源代码给替换了。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="缺点2：宏替换问题"><a href="#缺点2：宏替换问题" class="headerlink" title="缺点2：宏替换问题"></a>缺点2：宏替换问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE <span class="meta-string">&quot;data.txt&quot;</span>  <span class="comment">// 本来我只想在本文件中使用这个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  // 但是没想到 stdio.h 里的 FILE 也被替换成 &quot;data.txt&quot; 了</span></span></span><br><span class="line"><span class="comment">// 编译器会报一些很难理解的错误。</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">/usr/include/stdio.h:195:34: error: expected constructor, destructor, or type conversion before ‘;’ token</span></span><br><span class="line"><span class="comment"> extern FILE *tmpfile (void) __wur;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 FILE 文件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图：CI 对 Header Guard 过短给出的建议<br><img src="https://cdn.zlrs.site/mweb/2021/07/27/16118301586367.jpg" alt="-w850"></p>
<h4 id="规避方法-workaround-1"><a href="#规避方法-workaround-1" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>每次使用宏时都加上前缀，如项目名等，并且全用大写加下划线（因为一般符号很少全是大写的）。比如<code>#define FILE &quot;data.txt&quot;</code>，替换成<code>#define PROJECTNAME_DATA_FILE &quot;data.txt&quot;</code>。</p>
<h3 id="缺点3：影响编译速度"><a href="#缺点3：影响编译速度" class="headerlink" title="缺点3：影响编译速度"></a>缺点3：影响编译速度</h3><p>(1) 头文件是嵌套<code>#include</code>的。一行普通的<code>#include &lt;stdio.h&gt;</code>，完全展开后可能有几千几万行代码。由于代码量很大，所以编译很耗时。<br>(2) 如果第(1)点的编译耗时是一次性的，那还可以接受。但是工程中有这样的情况: 几乎每个编译单元（源文件）都要引入同一个头文件，比如 <code>UIKit.h</code>。编译单元之间对头文件的编译产物无法复用。假如工程中有M个源文件，N个头文件，则项目的编译最多可以达到 MxN 的复杂度。这样的项目是非拓展性的(unscaleable)。</p>
<h4 id="规避方法-workaround-2"><a href="#规避方法-workaround-2" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>使用pch(precompiled header). pch解决了上面提到的第(2)个问题。程序员将一些共用的头文件写在<code>.pch</code>文件中。<code>.pch</code>中的头文件会被预先编译好，并在每个源文件中默认引入。<code>pch</code>的确提高了编译速度。但是<code>pch</code>由于会被默认引入到每个源文件，这个解法其实很不好，因为它带来了名字空间污染(namespace polution)。</p>
<h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><p><code>#import</code>是Objective-C预处理器引入的一个特性。它仍然是文本插入，但是可以保证同一个编译单元中，同一头文件的内容只被插入一次。<br>更详细的可以看StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/439662/what-is-the-difference-between-import-and-include-in-objective-c">What is the difference between #import and #include in Objective-C?</a>。</p>
<h2 id="import-1"><a href="#import-1" class="headerlink" title="@import"></a>@import</h2><p>我们可以先把目光从C系语言转移到JS、Python等语言。JS和Python都没有头文件，他们遵循的是modules的概念。一般<code>module</code>是一个文件，这个文件<code>export</code>出一些接口；其它文件可以<code>import</code>一个module，从而调用它暴露出来的接口。<br>在python中，我们可以import一个module任意次，而且当Python VM启动之后，只有第一次引入时才会执行module文件，然后把该module缓存到一个哈希表中，随后的引用将直接从哈希表中取得module。JS的<code>require(module)</code>也是类似的原理。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091712656983.jpg" alt="python中可以import一个module任意次"></p>
<p>在iOS7(WWDC 2013)中，苹果为OC引入了modules机制，对应的关键字就是<code>@import</code>。<br>OC的modules有以下特点：</p>
<ol>
<li><p>不是文本插入(textual inclusion). </p>
</li>
<li><p>第二次被<code>@import</code>的module不需要重新编译。大大提高了编译速度。（尤其对于那些不使用或不经常维护<code>pch</code>的项目）</p>
</li>
<li><p>通过<code>modulemap</code>文件关联umbrella头文件和module，并export submodule。顺便我们还可以在<code>modulemap</code>中写link指令，这样就可以自动链接上framework.<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091729424173.jpg" alt="-w849"><br>由于modules的Auto-Link特性，我们的工程在<code>Build Phases</code>中不需要引入<code>UIKit.framwork</code>, <code>Foundation.framwork</code>等依赖。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091731649362.jpg" alt="-w856"></p>
</li>
<li><p>header is the truth。编译器最后做了什么，最后还是看header。类的接口也是依然写在header中，而不是<code>export</code>出来。</p>
</li>
<li><p>Xcode 新项目默认开启modules。现有项目(iOS 7.0+)一般都开启了这个功能。开启后，若该头文件能通过modulemap对应到某个module，则这条<code>#import</code>会被视做<code>@import</code>。因此开发者在OC工程中写的对系统库头文件和Cocoapods组件头文件的<code>#import</code>(如<code>#import &lt;MapKit/MapKit.h&gt;</code>)，大多数情况下已经不是直接的文本插入了，而是被Xcode视作<code>@import</code>(<code>@import MapKit</code>）。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091727588022.jpg" alt="现有项目一般都开启了modules"></p>
</li>
<li><p>我们自己的SDK也可以使用module的特性。看起来cocoapods会帮助我们做这件事。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091734906367.jpg" alt="cocoapods自动生成的modulemap文件"></p>
</li>
</ol>
<p>更详细的可以看<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>和 StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18947516/import-vs-import-ios-7">@import vs #import - iOS 7</a>。</p>
<h2 id="modules-in-C"><a href="#modules-in-C" class="headerlink" title="modules in C++"></a>modules in C++</h2><p>苹果的工程师将OC的这套modules实现借鉴到C++上，并做了在2012年做了一个分享。<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=4Xo9iH5VLQ0">C++ Modules proposal</a>(2012年12月5日)</p>
<p>现在modules已经进入C++20，标准规定和苹果当初提出的方案挺相似的。也是基于<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/Modules.html#module-map-language">modulemap</a>实现的。</p>
<p>有关C++20 modules的更多信息，可以看下面的视频和资料。<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=6SKIUeRaLZE">Demo: C++20 Modules</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FRkJCvHWdwQ&t=232s">C++20: An (Almost) Complete Overview - Marc Gregoire - CppCon 2020</a></p>
<p><a target="_blank" rel="noopener" href="https://mariusbancila.ro/blog/2020/05/15/modules-in-clang-11/">Modules in Clang 11</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33307657/how-do-i-use-c-modules-in-clang">How do I use C++ modules in Clang?</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="zlrs.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/C/">C++</a><small>1</small></li>
  
    <li><a href="/tags/ProgramDesign/">ProgramDesign</a><small>1</small></li>
  
    <li><a href="/tags/iOS-Objective-C-WWDC/">iOS Objective-C WWDC</a><small>1</small></li>
  
    <li><a href="/tags/macOS-iOS/">macOS iOS</a><small>3</small></li>
  
    <li><a href="/tags/%E7%BD%91%E7%BB%9C-iOS-macOS/">网络 iOS macOS</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 zlrs
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
