<!DOCTYPE HTML>
<html lang="zh_CN">
<head>
  <meta charset="utf-8">
  
  <title>zlrs - blog</title>
  <meta name="author" content="zlrs">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="zlrs - blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">zlrs - blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-误用单例模式造成的问题（以开发一个SDK为例）" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-08-14T18:59:01.000Z"><a href="/2021/08/14/%E8%AF%AF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BB%A5%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AASDK%E4%B8%BA%E4%BE%8B%EF%BC%89/">2021-08-14</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/14/%E8%AF%AF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%80%A0%E6%88%90%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E4%BB%A5%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AASDK%E4%B8%BA%E4%BE%8B%EF%BC%89/">误用单例模式造成的问题（以开发一个SDK为例）</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>这里以开发一个AppLog SDK的例子来说明误用单例模式会造成哪些问题。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>开发的第一步，是确定SDK的功能。我们假设AppLog SDK有以下功能：</p>
<ul>
<li>埋点上报</li>
<li>本次启动未来得及上报的埋点，可以在下次启动时上报</li>
<li>能自动为以下事件做埋点：应用启动、进入前台、进入后台和应用退出</li>
</ul>
<h2 id="细分功能点和讨论软件开发面"><a href="#细分功能点和讨论软件开发面" class="headerlink" title="细分功能点和讨论软件开发面"></a>细分功能点和讨论软件开发面</h2><ul>
<li>埋点上报<ul>
<li>需要一个SDK主类，作为用户界面</li>
</ul>
</li>
<li>本次启动未来得及上报的埋点，可以在下次启动时上报<ul>
<li>埋点数据要持久化到磁盘。需要数据库访问层（DAO）。</li>
<li>需要埋点上报层，并支持不同上报策略（定时上报，手动触发上报等）</li>
</ul>
</li>
<li>能自动为以下事件做埋点：应用启动、进入前台、进入后台和应用退出<ul>
<li>需要一个监听上述生命周期事件的对象</li>
</ul>
</li>
</ul>
<h2 id="讨论实现：完全使用单例模式来实现"><a href="#讨论实现：完全使用单例模式来实现" class="headerlink" title="讨论实现：完全使用单例模式来实现"></a>讨论实现：完全使用单例模式来实现</h2><p>经过以上两步我们分析完了AppLog SDK的功能点，并分出了用户界面层、数据库访问层、上报服务层和应用生命周期埋点层。我简单花了一个层级图表示层间的关系。（这张图不能完全反映软件的真实关系，比如若用户有手动触发上报的需求，则用户页面也需要依赖上报服务的上报接口，从而用户界面画成“L形”会更合适。但是这并不妨碍我们接下来的分析。）</p>
<p> <img src="media/16289268309087/16289281989139.jpg" alt="我们划分出的软件层级"></p>
<p> 因为每个层最少使用一个对象就可以完成，所以我们很容易想到用每个层都用一个单例。可以定义以下单例：</p>
<ul>
<li>[AppLogSDK sharedInstance]</li>
<li>[AppLogSDKImpl sharedInstance]</li>
<li>[AppLogDAO sharedInstance]</li>
<li>[AppLogReportService sharedInstance]</li>
<li>[AppLogAppLifeCycleTrack sharedInstance]</li>
</ul>
<p>单例之间的通信就是层间通信。5个单例的相互通信实现了埋点数据的流转。这可以让我们的SDK正常工作。但是存在以下代价：</p>
<ol>
<li>单例具有“惯性”。因为后续的开发者会贴近之前代码的实现风格，所以仓库中的单例会随着时间越来越多。可能某个需求用单例实现是不够佳的，但是因为codebase中已经全是单例了，所以后续的开发者往往也会用单例来实现。</li>
<li>难以看清类之间的依赖关系。这是因为单例具有全局名字空间，所以依赖一个单例的对象无需在其接口（成员变量）中声明，而只需要随用随取即可。为了确定依赖，我们不得不去看代码中具体的调用点。（特别是在Objective-C中，一个类的代码可能分布在多个文件，更是令人头疼）这也为静态分析、依赖分析工具的开发增加了难度。当然，作为软件的第一任开发者和依赖关系的最初设计者，你在一开始肯定了解这其中的关系，只是对于新人和N月后再看代码的你来说有难度。</li>
<li>难以编写单元测试。单元测试简单的说就是先确定一个类所有重要的test case，通过mock掉它所有的依赖+并运行被测代码(CUT, Code Under Test)来确定这个类的代码有没有问题。但是由于单例是随用随取的，我们很难去mock CUT对单例的依赖。(在这里例子里，由于AppLogImpl直接依赖了AppLogDAO单例，test case就无从mock数据库依赖)这样我们就无法确定出错时是CUT的错误还是依赖的错误；甚至单测通过时也无法确定是否是“错错得对”。</li>
<li>容易承担过多职责，造成类级别的职责混乱。由于众多单例之间交叉调用的数据流是非常难解读的，而需求紧急时没有足够的时间去了解整个codebase的数据流。这样新人做需求时就容易往已有的单例上添加其他职责，造成职责混乱。</li>
<li>内存占用较高。单例具有静态生命周期，只有在进程退出时才会被析构。当不再需要某个单例时，这个单例也会一直存在，直到进程退出。</li>
<li>较难找到单例的创建时间。要确定单例的创建时间，得先找到所有<code>sharedInstance</code>的调用点，然后在这些调用点中找到时间上最前的那个。当你要为单例注入外部依赖时，弄清这一点是很重要的，否则外部依赖的注入可能晚于单例第一个方法调用。</li>
<li>当未来需求变化时有潜在的巨大改造成本。想象一下，当单例难以满足新增需求时，如需求要求有多个埋点渠道、上报渠道、数据库为了合规也得按渠道隔离；那么单例的设计就会存在很大的改造成本。</li>
</ol>
<h2 id="讨论实现：使用组合设计模式来实现"><a href="#讨论实现：使用组合设计模式来实现" class="headerlink" title="讨论实现：使用组合设计模式来实现"></a>讨论实现：使用组合设计模式来实现</h2><p>Wikipedia对组合设计模式（Composite pattern）的介绍如下：</p>
<blockquote>
<p>In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes a group of objects that are treated the same way as a single instance of the same type of object. The intent of a composite is to “compose” objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.</p>
</blockquote>
<p>在功能上，SDK的各个功能是由各个子模块的功能所组成的。在程序结构上，SDK的主类对象也可以是由多个子模块的对象所组成。成员类型可以是Inteface或者抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class AppLogSDKImpl &#123;</span><br><span class="line">   &#x2F;&#x2F; instance properties</span><br><span class="line">   AppLogDAOInteface dao,</span><br><span class="line">   AppLogReportServiceInteface reportService,</span><br><span class="line">   AppLogAppLifeCycleTrackInteface lifeCycleTrack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="media/16289268309087/16289382645371.jpg" alt="组合设计模式形成的树形成员关系图"></p>
<p>相比单例，这带来了以下好处</p>
<ul>
<li>方便搞清类间依赖关系。只需要阅读类的接口代码，就能知道其依赖。相关工具的开发也因此简便。</li>
<li>方便单元测试。子模块的对象作为主类对象的成员，可以应用接口抽象、继承或者依赖注入，便于被测试用例mock。每个类都可以被轻松地剥离出应用，并在注入mock依赖后成为一个独立的子系统。</li>
<li>有助于维护单一职责模型。由于无法被当做全局变量使用，就不会有人出于偷懒，把一些职责挂载到其它对象上。</li>
<li>功能更强大，能更好地应对需求变更。</li>
</ul>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>熟悉面向对象不仅仅是熟悉面向对象语言的关键词和语法而已，更重要的是</p>
<ul>
<li>在语言无关的层面熟悉面向对象的思想</li>
<li>了解设计模式和对象关系图（类成员依赖关系图、对象创建关系图、函数调用关系图）</li>
<li>多写代码，多看好的代码</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/137975/what-are-drawbacks-or-disadvantages-of-singleton-pattern">What are drawbacks or disadvantages of singleton pattern?</a></li>
<li><a target="_blank" rel="noopener" href="https://testing.googleblog.com/2008/08/by-miko-hevery-so-you-join-new-project.html">Singletons are Pathological Liars</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-NSURLRequest网络调试技巧" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-02-07T00:00:00.000Z"><a href="/2021/02/07/NSURLRequest%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">2021-02-07</a></time>
      
      
  
    <h1 class="title"><a href="/2021/02/07/NSURLRequest%E7%BD%91%E7%BB%9C%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">NSURLRequest网络调试技巧</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h2 id="快速阅读"><a href="#快速阅读" class="headerlink" title="快速阅读"></a>快速阅读</h2><ol>
<li>本文提供了一个<code>NSURLRequest</code>分类，便于在运行时捕获URL请求对象的请求信息。</li>
<li>本文介绍了VSCode插件<code>REST Client</code>的使用方法。</li>
<li>本文介绍了如何将上面两者配合使用，从而方便iOS/macOS客户端同学调试网络请求。</li>
</ol>
<p>这个方法原理是先把NSURLRequest以「HTTP格式」或「cURL格式」打印出来，然后利用VSCode的「REST Client」插件或者终端随时修改请求内容，便于调试请求。</p>
<h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><ol>
<li> 在客户端代码中添加下面的分类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSURLRequest (DEBUG)</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line"></span><br><span class="line">&#x2F;* 生成VSCode「REST Client」插件所需要的请求格式（HTTP 语言） *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString *)debug_VSCodeRESTClientPlugin_HTTP &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *result &#x3D; [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;%@ %@ %@\n&quot;, self.HTTPMethod, self.URL.absoluteString, @&quot;HTTP&#x2F;1.1&quot;]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NSDictionary *fields &#x3D; self.allHTTPHeaderFields;</span><br><span class="line"></span><br><span class="line">    for (NSString *headerName in fields) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *headerVal &#x3D; fields[headerName];</span><br><span class="line"></span><br><span class="line">        [result appendString:[NSString stringWithFormat:@&quot;%@: %@\n&quot;, headerName, headerVal]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    NSString *body &#x3D; [[NSString alloc] initWithData:self.HTTPBody encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;\n%@\n\n###&quot;, body]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* 生成VSCode「REST Client」插件所需要的请求格式（cURL 格式） *&#x2F;</span><br><span class="line"></span><br><span class="line">- (NSString *)debug_VSCodeRESTClientPlugin_cURL &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *result &#x3D; [[NSMutableString alloc] init];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;curl -i -X %@ &quot;, self.HTTPMethod]];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;\&quot;%@\&quot; &quot;, self.URL.absoluteString]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    NSDictionary *fields &#x3D; self.allHTTPHeaderFields;</span><br><span class="line"></span><br><span class="line">    for (NSString *headerName in fields) &#123;</span><br><span class="line"></span><br><span class="line">        NSString *headerVal &#x3D; fields[headerName];</span><br><span class="line"></span><br><span class="line">        [result appendString:[NSString stringWithFormat:@&quot;-H \&quot;%@: %@\&quot; &quot;, headerName, headerVal]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    NSString *body &#x3D; [[NSString alloc] initWithData:self.HTTPBody encoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    [result appendString:[NSString stringWithFormat:@&quot;-d \&quot;%@\&quot;&quot;, body]];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 在VSCode上安装 <strong>REST Client</strong> 插件</li>
</ol>
<p><strong>REST Client</strong> 是一个用于调试网络请求的VSCode插件。其功能和Postman类似。其特点是纯文本操作，不需要用鼠标在GUI上点点点，熟练使用后调试效率较高。</p>
<p><strong>REST Client</strong> 的使用方式非常简单，在VSCode中新建一个<code>.http</code>或<code>.rest</code>拓展名的文件，然后在文件中书写「HTTP格式」或「cURL格式」的请求代码。点击代码头部或右键菜单中的<code>send Request</code>发送请求，就可以在右侧看到响应了。</p>
<p><img src="https://raw.githubusercontent.com/Huachao/vscode-restclient/master/images/response.gif"></p>
<h2 id="使用方法（HTTP-格式）"><a href="#使用方法（HTTP-格式）" class="headerlink" title="使用方法（HTTP 格式）"></a>使用方法（HTTP 格式）</h2><ol>
<li> 在需要调试的地方调用分类方法，把URL请求对象“捕获”下来</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; xxx;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [request debug_VSCodeRESTClientPlugin_HTTP]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p> 在VSCode中打开一个http后缀名的文件，把输出的内容贴到xxx.http文件里。<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650141059.jpg"></p>
</li>
<li><p> 在右键菜单中点击 sendRequest，就可以发出请求，并在右侧看到服务端的响应了。<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650346776.jpg"></p>
</li>
<li><p> 如果请求参数需要调整，直接在文件中修改并重新发送请求即可。比如上面的截图中，服务端查询返回的是一个空数组。这时候我们就可以方便地修改请求query，很快就能查看修改后的效果。</p>
</li>
</ol>
<h2 id="使用方法（cURL格式）"><a href="#使用方法（cURL格式）" class="headerlink" title="使用方法（cURL格式）"></a>使用方法（cURL格式）</h2><ol>
<li> 打印cURL格式命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableURLRequest *request &#x3D; xxx;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [request debug_VSCodeRESTClientPlugin_cURL]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li> 可以复制到终端中使用，也可以在VSCode「REST Client」插件中调用。<br>通过终端使用:<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650482513.jpg"><br>通过「REST Client」插件使用：<br><img src="https://cdn.zlrs.site/mweb/2021/07/28/16274650604452.jpg"></li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>目前只考虑到了HTTPBody为文本的情况，如果HTTPBody是二进制就需要自己修改下分类代码。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-inclue-import-and-import-in-Objective-C" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-12-29T20:44:35.000Z"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">2020-12-29</a></time>
      
      
  
    <h1 class="title"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">#inclue, #import, and @import in Objective-C</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>最近在看WWDC中关于Objective-C的一些视频。正好看到<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>中提到Objective-C modules的内容。正好又联系上最近C++群里讨论比较多的 <code>C++20 modules</code>，感觉可以做个总结~</p>
</blockquote>
<table>
<thead>
<tr>
<th>语法(semantic)</th>
<th>归属模块</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>传统预处理器</td>
<td>文本插入(textual inclusion)，没有别的trick</td>
</tr>
<tr>
<td>#import</td>
<td>Objective-C的预处理器</td>
<td>文本插入。但能保证不重复引入头文件</td>
</tr>
<tr>
<td>@import</td>
<td>Objective-C(iOS 7.0+)</td>
<td>Objective-C modules</td>
</tr>
</tbody></table>
<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><p><code>#include</code>是一个支撑了C系语言几十年的机制。它就是简单的文本插入，没有别的trick。在C语言里，函数声明写在<code>.h</code>头文件中，函数实现写在<code>.c</code>源文件中。<code>#include &quot;xxx.h&quot;</code>就是先把<code>xxx.h</code>的文本插入到<code>#include &quot;xxx.h&quot;</code>所在的位置；如果插入的文本中还有<code>#include</code>就继续插入。<br>它有3个缺点，当然对应的也有workaround。</p>
<h3 id="缺点1：可能重复引入头文件"><a href="#缺点1：可能重复引入头文件" class="headerlink" title="缺点1：可能重复引入头文件"></a>缺点1：可能重复引入头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;  // compile error: redefinition of ‘int add(int, int)’</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="规避方法-workaround"><a href="#规避方法-workaround" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>Header guard.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="comment">// Header Guard有项目名前缀+文件名前缀，是为了避免一不小心把源代码给替换了。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="缺点2：宏替换问题"><a href="#缺点2：宏替换问题" class="headerlink" title="缺点2：宏替换问题"></a>缺点2：宏替换问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE <span class="meta-string">&quot;data.txt&quot;</span>  <span class="comment">// 本来我只想在本文件中使用这个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  // 但是没想到 stdio.h 里的 FILE 也被替换成 &quot;data.txt&quot; 了</span></span></span><br><span class="line"><span class="comment">// 编译器会报一些很难理解的错误。</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">/usr/include/stdio.h:195:34: error: expected constructor, destructor, or type conversion before ‘;’ token</span></span><br><span class="line"><span class="comment"> extern FILE *tmpfile (void) __wur;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 FILE 文件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图：CI 对 Header Guard 过短给出的建议<br><img src="https://cdn.zlrs.site/mweb/2021/07/27/16118301586367.jpg" alt="-w850"></p>
<h4 id="规避方法-workaround-1"><a href="#规避方法-workaround-1" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>每次使用宏时都加上前缀，如项目名等，并且全用大写加下划线（因为一般符号很少全是大写的）。比如<code>#define FILE &quot;data.txt&quot;</code>，替换成<code>#define PROJECTNAME_DATA_FILE &quot;data.txt&quot;</code>。</p>
<h3 id="缺点3：影响编译速度"><a href="#缺点3：影响编译速度" class="headerlink" title="缺点3：影响编译速度"></a>缺点3：影响编译速度</h3><p>(1) 头文件是嵌套<code>#include</code>的。一行普通的<code>#include &lt;stdio.h&gt;</code>，完全展开后可能有几千几万行代码。由于代码量很大，所以编译很耗时。<br>(2) 如果第(1)点的编译耗时是一次性的，那还可以接受。但是工程中有这样的情况: 几乎每个编译单元（源文件）都要引入同一个头文件，比如 <code>UIKit.h</code>。编译单元之间对头文件的编译产物无法复用。假如工程中有M个源文件，N个头文件，则项目的编译最多可以达到 MxN 的复杂度。这样的项目是非拓展性的(unscaleable)。</p>
<h4 id="规避方法-workaround-2"><a href="#规避方法-workaround-2" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>使用pch(precompiled header). pch解决了上面提到的第(2)个问题。程序员将一些共用的头文件写在<code>.pch</code>文件中。<code>.pch</code>中的头文件会被预先编译好，并在每个源文件中默认引入。<code>pch</code>的确提高了编译速度。但是<code>pch</code>由于会被默认引入到每个源文件，这个解法其实很不好，因为它带来了名字空间污染(namespace polution)。</p>
<h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><p><code>#import</code>是Objective-C预处理器引入的一个特性。它仍然是文本插入，但是可以保证同一个编译单元中，同一头文件的内容只被插入一次。<br>更详细的可以看StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/439662/what-is-the-difference-between-import-and-include-in-objective-c">What is the difference between #import and #include in Objective-C?</a>。</p>
<h2 id="import-1"><a href="#import-1" class="headerlink" title="@import"></a>@import</h2><p>我们可以先把目光从C系语言转移到JS、Python等语言。JS和Python都没有头文件，他们遵循的是modules的概念。一般<code>module</code>是一个文件，这个文件<code>export</code>出一些接口；其它文件可以<code>import</code>一个module，从而调用它暴露出来的接口。<br>在python中，我们可以import一个module任意次，而且当Python VM启动之后，只有第一次引入时才会执行module文件，然后把该module缓存到一个哈希表中，随后的引用将直接从哈希表中取得module。JS的<code>require(module)</code>也是类似的原理。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091712656983.jpg" alt="python中可以import一个module任意次"></p>
<p>在iOS7(WWDC 2013)中，苹果为OC引入了modules机制，对应的关键字就是<code>@import</code>。<br>OC的modules有以下特点：</p>
<ol>
<li><p>不是文本插入(textual inclusion). </p>
</li>
<li><p>第二次被<code>@import</code>的module不需要重新编译。大大提高了编译速度。（尤其对于那些不使用或不经常维护<code>pch</code>的项目）</p>
</li>
<li><p>通过<code>modulemap</code>文件关联umbrella头文件和module，并export submodule。顺便我们还可以在<code>modulemap</code>中写link指令，这样就可以自动链接上framework.<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091729424173.jpg" alt="-w849"><br>由于modules的Auto-Link特性，我们的工程在<code>Build Phases</code>中不需要引入<code>UIKit.framwork</code>, <code>Foundation.framwork</code>等依赖。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091731649362.jpg" alt="-w856"></p>
</li>
<li><p>header is the truth。编译器最后做了什么，最后还是看header。类的接口也是依然写在header中，而不是<code>export</code>出来。</p>
</li>
<li><p>Xcode 新项目默认开启modules。现有项目(iOS 7.0+)一般都开启了这个功能。开启后，若该头文件能通过modulemap对应到某个module，则这条<code>#import</code>会被视做<code>@import</code>。因此开发者在OC工程中写的对系统库头文件和Cocoapods组件头文件的<code>#import</code>(如<code>#import &lt;MapKit/MapKit.h&gt;</code>)，大多数情况下已经不是直接的文本插入了，而是被Xcode视作<code>@import</code>(<code>@import MapKit</code>）。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091727588022.jpg" alt="现有项目一般都开启了modules"></p>
</li>
<li><p>我们自己的SDK也可以使用module的特性。看起来cocoapods会帮助我们做这件事。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091734906367.jpg" alt="cocoapods自动生成的modulemap文件"></p>
</li>
</ol>
<p>更详细的可以看<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>和 StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18947516/import-vs-import-ios-7">@import vs #import - iOS 7</a>。</p>
<h2 id="modules-in-C"><a href="#modules-in-C" class="headerlink" title="modules in C++"></a>modules in C++</h2><p>苹果的工程师将OC的这套modules实现借鉴到C++上，并做了在2012年做了一个分享。<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=4Xo9iH5VLQ0">C++ Modules proposal</a>(2012年12月5日)</p>
<p>现在modules已经进入C++20，标准规定和苹果当初提出的方案挺相似的。也是基于<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/Modules.html#module-map-language">modulemap</a>实现的。</p>
<p>有关C++20 modules的更多信息，可以看下面的视频和资料。<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=6SKIUeRaLZE">Demo: C++20 Modules</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FRkJCvHWdwQ&t=232s">C++20: An (Almost) Complete Overview - Marc Gregoire - CppCon 2020</a></p>
<p><a target="_blank" rel="noopener" href="https://mariusbancila.ro/blog/2020/05/15/modules-in-clang-11/">Modules in Clang 11</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33307657/how-do-i-use-c-modules-in-clang">How do I use C++ modules in Clang?</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="zlrs.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/iOS-Objective-C-WWDC/">iOS Objective-C WWDC</a><small>1</small></li>
  
    <li><a href="/tags/%E7%BD%91%E7%BB%9C-iOS-macOS/">网络 iOS macOS</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 zlrs
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
