<!DOCTYPE HTML>
<html lang="zh_CN">
<head>
  <meta charset="utf-8">
  
  <title>#inclue, #import, and @import in Objective-C | zlrs - blog</title>
  <meta name="author" content="zlrs">
  
  <meta name="description" content="最近在看WWDC中关于Objective-C的一些视频。正好看到WWDC2013-404 Advances in Objective-C中提到Objective-C modules的内容。正好又联系上最近C++群里讨论比较多的 C++20 modules，感觉可以做个总结~




语法(seman">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="#inclue, #import, and @import in Objective-C"/>
  <meta property="og:site_name" content="zlrs - blog"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">zlrs - blog</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-inclue-import-and-import-in-Objective-C" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-12-29T20:44:35.000Z"><a href="/2020/12/29/inclue-import-and-import-in-Objective-C/">2020-12-29</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">#inclue, #import, and @import in Objective-C</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <blockquote>
<p>最近在看WWDC中关于Objective-C的一些视频。正好看到<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>中提到Objective-C modules的内容。正好又联系上最近C++群里讨论比较多的 <code>C++20 modules</code>，感觉可以做个总结~</p>
</blockquote>
<table>
<thead>
<tr>
<th>语法(semantic)</th>
<th>归属模块</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>传统预处理器</td>
<td>文本插入(textual inclusion)，没有别的trick</td>
</tr>
<tr>
<td>#import</td>
<td>Objective-C的预处理器</td>
<td>文本插入。但能保证不重复引入头文件</td>
</tr>
<tr>
<td>@import</td>
<td>Objective-C(iOS 7.0+)</td>
<td>Objective-C modules</td>
</tr>
</tbody></table>
<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><p><code>#include</code>是一个支撑了C系语言几十年的机制。它就是简单的文本插入，没有别的trick。在C语言里，函数声明写在<code>.h</code>头文件中，函数实现写在<code>.c</code>源文件中。<code>#include &quot;xxx.h&quot;</code>就是先把<code>xxx.h</code>的文本插入到<code>#include &quot;xxx.h&quot;</code>所在的位置；如果插入的文本中还有<code>#include</code>就继续插入。<br>它有3个缺点，当然对应的也有workaround。</p>
<h3 id="缺点1：可能重复引入头文件"><a href="#缺点1：可能重复引入头文件" class="headerlink" title="缺点1：可能重复引入头文件"></a>缺点1：可能重复引入头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;add.h&gt;  // compile error: redefinition of ‘int add(int, int)’</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="规避方法-workaround"><a href="#规避方法-workaround" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>Header guard.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="comment">// Header Guard有项目名前缀+文件名前缀，是为了避免一不小心把源代码给替换了。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECTNAME_ADD_HEADER_GUARD</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="缺点2：宏替换问题"><a href="#缺点2：宏替换问题" class="headerlink" title="缺点2：宏替换问题"></a>缺点2：宏替换问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE <span class="meta-string">&quot;data.txt&quot;</span>  <span class="comment">// 本来我只想在本文件中使用这个宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  // 但是没想到 stdio.h 里的 FILE 也被替换成 &quot;data.txt&quot; 了</span></span></span><br><span class="line"><span class="comment">// 编译器会报一些很难理解的错误。</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">/usr/include/stdio.h:195:34: error: expected constructor, destructor, or type conversion before ‘;’ token</span></span><br><span class="line"><span class="comment"> extern FILE *tmpfile (void) __wur;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 FILE 文件</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图：CI 对 Header Guard 过短给出的建议<br><img src="https://cdn.zlrs.site/mweb/2021/07/27/16118301586367.jpg" alt="-w850"></p>
<h4 id="规避方法-workaround-1"><a href="#规避方法-workaround-1" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>每次使用宏时都加上前缀，如项目名等，并且全用大写加下划线（因为一般符号很少全是大写的）。比如<code>#define FILE &quot;data.txt&quot;</code>，替换成<code>#define PROJECTNAME_DATA_FILE &quot;data.txt&quot;</code>。</p>
<h3 id="缺点3：影响编译速度"><a href="#缺点3：影响编译速度" class="headerlink" title="缺点3：影响编译速度"></a>缺点3：影响编译速度</h3><p>(1) 头文件是嵌套<code>#include</code>的。一行普通的<code>#include &lt;stdio.h&gt;</code>，完全展开后可能有几千几万行代码。由于代码量很大，所以编译很耗时。<br>(2) 如果第(1)点的编译耗时是一次性的，那还可以接受。但是工程中有这样的情况: 几乎每个编译单元（源文件）都要引入同一个头文件，比如 <code>UIKit.h</code>。编译单元之间对头文件的编译产物无法复用。假如工程中有M个源文件，N个头文件，则项目的编译最多可以达到 MxN 的复杂度。这样的项目是非拓展性的(unscaleable)。</p>
<h4 id="规避方法-workaround-2"><a href="#规避方法-workaround-2" class="headerlink" title="规避方法(workaround)"></a>规避方法(workaround)</h4><p>使用pch(precompiled header). pch解决了上面提到的第(2)个问题。程序员将一些共用的头文件写在<code>.pch</code>文件中。<code>.pch</code>中的头文件会被预先编译好，并在每个源文件中默认引入。<code>pch</code>的确提高了编译速度。但是<code>pch</code>由于会被默认引入到每个源文件，这个解法其实很不好，因为它带来了名字空间污染(namespace polution)。</p>
<h2 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h2><p><code>#import</code>是Objective-C预处理器引入的一个特性。它仍然是文本插入，但是可以保证同一个编译单元中，同一头文件的内容只被插入一次。<br>更详细的可以看StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/439662/what-is-the-difference-between-import-and-include-in-objective-c">What is the difference between #import and #include in Objective-C?</a>。</p>
<h2 id="import-1"><a href="#import-1" class="headerlink" title="@import"></a>@import</h2><p>我们可以先把目光从C系语言转移到JS、Python等语言。JS和Python都没有头文件，他们遵循的是modules的概念。一般<code>module</code>是一个文件，这个文件<code>export</code>出一些接口；其它文件可以<code>import</code>一个module，从而调用它暴露出来的接口。<br>在python中，我们可以import一个module任意次，而且当Python VM启动之后，只有第一次引入时才会执行module文件，然后把该module缓存到一个哈希表中，随后的引用将直接从哈希表中取得module。JS的<code>require(module)</code>也是类似的原理。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091712656983.jpg" alt="python中可以import一个module任意次"></p>
<p>在iOS7(WWDC 2013)中，苹果为OC引入了modules机制，对应的关键字就是<code>@import</code>。<br>OC的modules有以下特点：</p>
<ol>
<li><p>不是文本插入(textual inclusion). </p>
</li>
<li><p>第二次被<code>@import</code>的module不需要重新编译。大大提高了编译速度。（尤其对于那些不使用或不经常维护<code>pch</code>的项目）</p>
</li>
<li><p>通过<code>modulemap</code>文件关联umbrella头文件和module，并export submodule。顺便我们还可以在<code>modulemap</code>中写link指令，这样就可以自动链接上framework.<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091729424173.jpg" alt="-w849"><br>由于modules的Auto-Link特性，我们的工程在<code>Build Phases</code>中不需要引入<code>UIKit.framwork</code>, <code>Foundation.framwork</code>等依赖。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091731649362.jpg" alt="-w856"></p>
</li>
<li><p>header is the truth。编译器最后做了什么，最后还是看header。类的接口也是依然写在header中，而不是<code>export</code>出来。</p>
</li>
<li><p>Xcode 新项目默认开启modules。现有项目(iOS 7.0+)一般都开启了这个功能。开启后，若该头文件能通过modulemap对应到某个module，则这条<code>#import</code>会被视做<code>@import</code>。因此开发者在OC工程中写的对系统库头文件和Cocoapods组件头文件的<code>#import</code>(如<code>#import &lt;MapKit/MapKit.h&gt;</code>)，大多数情况下已经不是直接的文本插入了，而是被Xcode视作<code>@import</code>(<code>@import MapKit</code>）。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091727588022.jpg" alt="现有项目一般都开启了modules"></p>
</li>
<li><p>我们自己的SDK也可以使用module的特性。看起来cocoapods会帮助我们做这件事。<br><img src="https://cdn.zlrs.site/mweb/2021/01/23/16091734906367.jpg" alt="cocoapods自动生成的modulemap文件"></p>
</li>
</ol>
<p>更详细的可以看<a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2013/404/">WWDC2013-404 Advances in Objective-C</a>和 StackOverflow: <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/18947516/import-vs-import-ios-7">@import vs #import - iOS 7</a>。</p>
<h2 id="modules-in-C"><a href="#modules-in-C" class="headerlink" title="modules in C++"></a>modules in C++</h2><p>苹果的工程师将OC的这套modules实现借鉴到C++上，并做了在2012年做了一个分享。<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=4Xo9iH5VLQ0">C++ Modules proposal</a>(2012年12月5日)</p>
<p>现在modules已经进入C++20，标准规定和苹果当初提出的方案挺相似的。也是基于<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/Modules.html#module-map-language">modulemap</a>实现的。</p>
<p>有关C++20 modules的更多信息，可以看下面的视频和资料。<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=6SKIUeRaLZE">Demo: C++20 Modules</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=FRkJCvHWdwQ&t=232s">C++20: An (Almost) Complete Overview - Marc Gregoire - CppCon 2020</a></p>
<p><a target="_blank" rel="noopener" href="https://mariusbancila.ro/blog/2020/05/15/modules-in-clang-11/">Modules in Clang 11</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33307657/how-do-i-use-c-modules-in-clang">How do I use C++ modules in Clang?</a></p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/iOS-Objective-C-WWDC/">iOS Objective-C WWDC</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://zlrs.github.io/2020/12/29/inclue-import-and-import-in-Objective-C/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="zlrs.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/C-C-11/">C++ C++11</a><small>1</small></li>
  
    <li><a href="/tags/Objective-C-runtime/">Objective-C runtime</a><small>1</small></li>
  
    <li><a href="/tags/Objetive-C-%E5%8E%86%E5%8F%B2/">Objetive-C 历史</a><small>1</small></li>
  
    <li><a href="/tags/ProgramDesign/">ProgramDesign</a><small>1</small></li>
  
    <li><a href="/tags/iOS-Objective-C-WWDC/">iOS Objective-C WWDC</a><small>1</small></li>
  
    <li><a href="/tags/macOS-iOS/">macOS iOS</a><small>3</small></li>
  
    <li><a href="/tags/%E7%BD%91%E7%BB%9C-iOS-macOS/">网络 iOS macOS</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 zlrs
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
